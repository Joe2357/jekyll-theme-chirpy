<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="MPBond: Efficient Network-level Collaboration Among Personal Mobile Devices" /><meta name="author" content="Joe2357" /><meta property="og:locale" content="en_US" /><meta name="description" content="2021 / 2 / 17 IMES 세미나" /><meta property="og:description" content="2021 / 2 / 17 IMES 세미나" /><link rel="canonical" href="https://joe2357.github.io/posts/MPBond/" /><meta property="og:url" content="https://joe2357.github.io/posts/MPBond/" /><meta property="og:site_name" content="Joe2357" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-01-21T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="MPBond: Efficient Network-level Collaboration Among Personal Mobile Devices" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Joe2357" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Joe2357"},"headline":"MPBond: Efficient Network-level Collaboration Among Personal Mobile Devices","dateModified":"2021-02-19T22:30:00+09:00","datePublished":"2021-01-21T00:00:00+09:00","description":"2021 / 2 / 17 IMES 세미나","url":"https://joe2357.github.io/posts/MPBond/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://joe2357.github.io/posts/MPBond/"},"@context":"https://schema.org"}</script><title>MPBond: Efficient Network-level Collaboration Among Personal Mobile Devices | Joe2357</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "AMS" } }, tex2jax: { inlineMath: [ ['$', '$'] ], displayMath: [ ['$$', '$$'] ], processEscapes: true, } }); MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) { alert("Math Processing Error: "+message[1]); }); MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) { alert("Math Processing Error: "+message[1]); }); </script> <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Joe2357</a></div><div class="site-subtitle font-italic">공부하는 블로그</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/Joe2357" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['deviljoe996','gachon.ac.kr'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>MPBond: Efficient Network-level Collaboration Among Personal Mobile Devices</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>MPBond: Efficient Network-level Collaboration Among Personal Mobile Devices</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Jan 21, 2021, 12:00 AM +0900" > Jan 21 <i class="unloaded">2021-01-21T00:00:00+09:00</i> </span> by <span class="author"> Joe2357 </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Fri, Feb 19, 2021, 10:30 PM +0900" > Feb 19 <i class="unloaded">2021-02-19T22:30:00+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="11604 words">64 min</span></div></div><div class="post-content"><blockquote><p>2021 / 2 / 17 IMES 세미나</p></blockquote><h2 id="abstract">Abstract</h2><ul><li>MPBond : 여러 개인 mobile device가 <u>공동으로 internet에서 content를 가져올 수 있도록</u> 하는 효율적인 system<ul><li>스마트워치 : data downloading을 통해 페어링된 스마트폰 지원<li>MPTCP ( Multipath TCP ) 에 영감을 받음<ul><li><i>distribute multipath transport</i> 개념 적용 ( 여러 subflow들이 다른 device로 traverse할 수 있음 )</ul><li>개발<ul><li>cross-device 연결 관리 scheme<li>buffering 전략<li>packet scheduling 알고리즘<li>MPBond architecture에 기반한 policy framework</ul><li>범용 mobile device에 MPBond를 구현하고 있음<li>다양한 network 조건에서 다른 workload를 이용한 <u>실제 평가</u><ul><li>MPBond의 효율성 증명<li>최신 협업 framework와의 비교<ul><li>file download time : 5% -&gt; 46% 단축<li>video streaming bitrate : 2% -&gt; 118% 향상<li>energy efficiency : 10% -&gt; 57% 개선</ul></ul></ul></ul><h2 id="introduction">Introduction</h2><ul><li>user가 여러 개의 mobile device를 가지고 있는 것이 일반적<ul><li>스마트워치 : <u>스마트폰과 페어링되어야 함</u><ul><li>대부분 2개의 휴대전화 ( 업무용, 개인용 ) 사용</ul></ul><li>스마트 mobile device : 여러 network interface 포함<ul><li><strong>원격 internet 서버, local device 등과 통신 가능</strong><li>핵심 : 협업적으로 작동할 수 있는 device network interface의 <u>잠재력은 완전히 이용되기 힘듬</u><li>mobile device <i>ecosystem</i>에 <strong>networking software 혁신</strong> 도입<ul><li><p><strong>MPBond</strong> 개발 : <u>여러 개인 mobile devices들이 공동으로 internet에서 content를 가져올 수 있는</u> 전체론적 system</p><ul><li>오늘날 mobile/wearable OS가 지원하지 못하는 것들을 가능하게 함<ol><li>스마트워치 : cellular를 통해 data를 download하여, 페어링된 스마트폰 지원<ul><li>현재 많은 COTS 스마트워치는 cellular에 직접 access 가능<li>단일 device를 사용하는 것보다 더 좋은 throughput 제공</ul><li>공공장소에서의 WiFi network : 각 interface마다 rate에 제한 부과<ul><li>각 device마다 WiFi interface가 있으므로, <i>multi-device collaboration</i>으로 극복 가능</ul><li>2개의 스마트폰이 LTE bandwidth를 공유할 수 있음<ul><li>cellular interface가 MPBond에 의해 <strong>결합</strong>되어지고, 하나의 가상 interface로 사용됨</ul><li>Wearable : 신호가 좋은 지점에 배치하여 WiFi/LTE <strong>range extenders</strong> 역할 수행 가능<ul><li>스마트폰 : 배터리가 부족한 경우 에너지 효율적인 BT link를 통해 페어링된 스마트워치로 power-hungry LTE access를 offload할 수 있음</ul></ol><li>위의 사용 사례들 : user data가 여러 subflow들에 분산되는 <u>multipath transport scheme</u>에서 <strong>실현될 수 있음</strong></ul></ul></ul><li><p>MPBond : subflow가 서로 다른 device들을 통과하는 distribute multipath를 지원해야함 ( 기존의 multipath paradigm (MPTCP) 과 다름 )</p><ul><li>client app이 실행되는 <strong>primary device</strong> / primary의 network 성능을 향상시키는 여러 <strong>helper devices</strong>로 구성<li>primary에서의 traffic : MPBond service에 의해 인터셉트<ul><li>local wireless link ( pipe ) 를 통해 helper들에게 traffic을 distribute<ul><li>helper : 각각 자신의 cellular interface를 통해 remote server로 traffic 전달</ul><li>나머지는 primary의 cellular interface를 통해 전송</ul><li>역방향 link ( downlink ) : 유사하게 작동<ul><li>server 또는 MPBond capable proxy : content를 primary와 helper들에게 distribute</ul><li>primary : 받은 모든 part를 merge -&gt; client app으로 content 전달</ul><li><p>MPBond scheme : <u>많은 challenge</u>를 안고 있음</p><ul><li>다른 기종들과 local wireless link를 적절히 관리하는 방법?<li>helper device를 전략적으로 활용하여 network 성능을 향상시키는 방법?<li>MPBond에 고유한 remote path와 local pipe를 모두 고려하는 강력한 multipath scheduler를 설계하는 방법?<li>user와 app에게 적절한 interface를 보이는 방법?<li>client와 server app에 대해 전체 MPBond system을 명료하게 만드는 방법?</ul><li><p>주요 design</p><ul><li>MPBond : distribute multipath transport 프레임워크<ul><li>subflow가 helper를 traverse하고 helper들이 pipe를 통해 primary device와 data를 교환할 수 있도록 함<li>다양한 wireless 기술을 이용하여 pipe를 유연하게 관리하는 scheme 개발<li>MPTCP의 control plane protocol 확장 -&gt; primary와 helper 조정<ul><li>distribute multipath와 pipe를 지원하기 위함</ul></ul><li>MPBond : 모든 subflow를 2개의 TCP flow로 분할<ul><li>분할된 결과<ul><li>primary와 helper 사이의 flow<li>helper와 server 사이의 flow</ul><li>TCP 분할 : MPBond ( internet과 pipe ) 의 경우에는 이기종 network에 걸친 end-to-end TCP session에 이득<ul><li>flow를 분할하기 전에 buffer를 설정할 수 있음 : network 상에서의 변동에 의한 부정적 성능 영향을 효과적으로 완화<li>신기술은 아님 : <strong>한 단계 더 발전시킴</strong><ul><li>mobile multipath 전송의 맥락에서, helper device에 적용</ul></ul></ul><li>PAMS ( Pipe-Aware Multipath Scheduler ) 개발 : 여러 subflow에게 traffic을 전략적으로 distribute<ul><li>MPBond 맞춤형으로 개조하기 위한 3가지 구성요소<ul><li>pipe, helper측 buffering, 이기종 network를 고려한 <strong>subflow latency 추정 module</strong><li>각 packet의 전송 latency를 낮추는 현명한 scheduling 결정을 위한 <strong>algorithm</strong><li>network 상태 변동, pipe를 통한 고장 가능성을 처리하는 <strong>smart reinjection scheme</strong></ul></ul><li>MPBond : 다양한 정책을 유연하게 지정할 수 있음<ul><li>app별 사용 권한 부여<li>각 device resource 소비 제한<li>traffic 우선순위 지정</ul></ul><li><p>상용 mobile device에 MPBond 구현</p><ul><li>app 투명성과 좋은 성능을 유지하면서 user space에서 구현할 수 있음<li>실제 mobile network로 체계적 평가<li>주요 평가 결과<ul><li>비교 대상 : kibbutz, COMBINE ( 최첨단 system )<ul><li>결과 : 다양한 workload, 광범위한 network 조건에서 energy 소비 10% ~ 57% 줄임<li>다양하고 wild한 network 환경에서, file download 시간 13% ~ 35% 줄임<ul><li>download 시간 감소 -&gt; 적은 energy 소비</ul></ul><li>bandwidth가 많이 필요한 360˚ video 스트리밍을 위해 적합한 QoE 제공하기 위해서는 <strong>3개의 협업 mobile device가 필요</strong><ul><li>MPBond dual mode의 효과 입증</ul></ul></ul><li><p>MPBond : distribute multipath 개념을 적용</p><ul><li><u>개인 mobile device간 network-level 협업 혁신을 이룬</u> 효율적이고 실용적인 system<li>다른 cross-device data sharing scheme보다 더 좋은 성능 제공<ul><li>PAMS scheduler에 의해 향상된 성능<li>app의 투명성<li>더 좋은 유연성</ul><li><strong>wearable 기기를 고려한 첫번째 연구</strong><li>GitHub에 open-source로 공개되어있음</ul></ul><h2 id="background-and-related-work">Background and Related Work</h2><h5 id="multipath-transport">Multipath Transport</h5><ul><li>여러 network path를 동시에 활용하여 <strong>data 전송을 가속화</strong>하는 기술<li>MPTCP ( 사실상 multipath solution ) : socket interface와 여러 기본 TCP subflow 사이에 shim layer 제공<ul><li>transport layer에서 작동 : app과 network 모두 <u>수정할 필요가 없음</u><li>가치 : 다른 path의 공동 사용에서 입증됨<ul><li>QoE가 다양한 internet app에서 주는 이점과 비슷</ul></ul><li>packet scheduler : multipath 전송 system에 <strong>핵심 요소</strong><ul><li>잠재적으로 이기종 network path를 통해 설정된 서로 다른 subflow에 data를 배포<li>MinRTT : MPTCP의 기본 scheduler<ul><li>congestion window의 가용 공간, 최소 network RTT를 이용한 path 선택</ul><li>MPTCP 성능을 향상시키기 위한 scheduling algorithm 혁신 연구도 있음<li>multipath transport protocol : 단일 host에서 subflow 설정<ul><li>MPTCP<li>MPRTP<li>MPQUIC<li>MP-H2<li>MP-RDMA</ul><li>MPBond : 협업하기 위해 <strong>subflow를 여러 mobile device를 통과하도록 distribute</strong></ul></ul><h5 id="multi-device-collaboration">Multi-device Collaboration</h5><ul><li>기존 work : data 전달을 위한 여러 device간의 network-level 협업을 해결하기 위해 다양한 노력<ul><li>Mobile kibbutz : tethering 기반 MPTCP 활용<ul><li>자신의 cellular interface를 이용하여 다른 tethering된 device의 cellular network를 통한 network data 전송<li>Android : USB 케이블 또는 wireless network를 이용하여 device P는 device C를 tethering할 수 있음<ul><li>wireless tethering을 사용하는 경우<ul><li>P가 WiFi AP 역할 수행 ( SoftAP mode )<li>WiFi를 통해 C로부터 traffic 수신<li>P의 LTE network를 통해 internet server로 전송 ( uplink traffic )</ul><li>downlink 방향도 비슷하게 작동<li>C는 2개의 local interface가 있음<ul><li>P에 연결될 WiFi interface<li>MPTCP를 적용할 수 있는 자체 LTE interface</ul></ul></ul></ul><li>PRISM : heavy-weight 메커니즘<ul><li>OS kernel에서 TCP stack을 수정, 다중 WWAN link에서 단일 TCP flow를 제거<li>custom proxy를 사용, 다른 device의 다중 WWAN 연결을 활용</ul><li>다른 network-level 협업 solution : app 계층에서 작동, 특정 app에 중점<ul><li>COMBINE : HTTP byte-range request 사용, wireless peer 간의 HTTP server에서 file을 공동으로 download<li>MicroCast : video streaming이 주 목표<li>Cool-Tether : web browsing traffic 전용, energy 효율적 cellular tethering 제안</ul><li>MPBond : 경량, 여러가지 이점 제공 ( 향상된 성능 등 )<ul><li>신중히 설계된 scheduler, app의 투명성, 더 좋은 유연성<li>MPBond 이외 연구들은 wearable에 적용되지 않음<li>network-level 협업 이외에도, 여러 mobile device 간에 다른 I/O resource를 공유하는 system 존재</ul></ul><h2 id="motivation">Motivation</h2><h3 id="1-incentives-to-carry-multiple-devices">1. Incentives to Carry Multiple Devices</h3><ul><li>user가 여러 mobile device를 가지는 것이 보편화 ( 업무용 / 개인용 등 )<ul><li>분리하여 사용 : data의 유출이나 손상을 최소화<li>통신사가 상호보완적 coverage 소지 =&gt; device를 바꾸면서 더 좋은 성능을 사용할 수 있음<ul><li>선불 요금제가 보급된 나라 ( 인도 ) 에서 인기</ul><li>WiFi 핫스팟 용으로 이전 phone 사용<li>roaming에 편리한 sim card가 장착된 phone 사용<li>배터리 불안 완화<li>도난 방지<li>여분의 저장공간 활용<li>중요한 data 백업</ul><li>phone을 새로 사서 여분으로 사용하지는 않음<ul><li>기존에 사용하던 오래된 phone을 여분으로써 사용</ul><li>스마트워치를 사용하는 것이 유행<ul><li>sim card가 내장 : cellular network에 접근할 수 있음<li>internet access 기능을 갖춘 dual / triple mobile device 조합이 가능<ul><li>스마트폰 + 태블릿<li>스마트폰 + 노트북 + 스마트워치</ul><li>device network interface 잠재력은 완전히 이용되지 못함</ul></ul><h3 id="2-benefits-of-multi-device-collaboration">2. Benefits of Multi-device Collaboration</h3><ul><li>device들 간의 network-level 협업 : network 성능 크게 향상 가능<li>기본 idea<ul><li>last-mile wireless hop이 bottleneck인 경우 : 여러 device로 동시에 download하는 것이 WWAN throughput 향상<li>여러 device에서 수신한 content : WLAN을 통해 병합 -&gt; app으로 전달</ul><li>WWAN측 throughput aggregation의 이점에 대해 실험적으로 입증<ul><li>이전의 연구에서는 거의 진행되지 않은 부분<li>서로 다른 cellular carrier를 사용하는 3개의 COTS mobile device 고려<ul><li>phone을 나란히 배치<li>1분동안 자신의 LTE network를 이용하여 인근 server에서 동시 대량 download 수행<li>200ms마다 TCP throughput 샘플링<li>3곳에서 실험<ul><li>대학 사무실<li>주택 아파트<li>식료품 가게</ul></ul><li>결과<ul><li>3개의 carrier가 각각 6.2Mbps ~ 61.8Mbps 범위의 중앙값 throughput으로, 3곳의 위치에서 다른 성능 보임<ul><li>특정 device가 특정 위치에서 더 좋은 성능을 보이지는 않음<li>app의 최소 QoE 요구를 충족 목적, live network 상태에 따라 <strong>최적의 device를 동적으로 선택</strong> 가능 ( MPBond가 지원 )</ul><li>WLAN측 merging이 bottleneck이 아닌 경우<ul><li>2개의 interface 사용 : 15.8% -&gt; 474.2% throughput 상승<li>3개의 device 사용 : 63.1% -&gt; 695.4% throughput 상승</ul><li>aggregated throughput : bandwidth를 많이 잡아먹는 app을 효율적으로 지원<ul><li>UHD video 스트리밍<li>mobile VR<li>mobile holographic communication</ul></ul></ul></ul><h3 id="3-networking-capability-of-wearables">3. Networking Capability of Wearables</h3><ul><li>위의 실험 : LTE 기능이 있는 스마트워치가 포함되어있음<ul><li>적절한 throughput을 가지고 있음 // 그래도 network capability에 대해 스마트폰이나 태블릿 등과 비교당할 우려<li>동일 년도에 출시한 스마트폰 vs 스마트워치를 이용하여 LTE throughput을 실험적으로 증명<ul><li>device 기능이 성능에 미치는 영향 테스트<li>실험 내용<ul><li>두 device에는 동일한 sim card ( AT&amp;T ) 를 반복적으로 삽입<li>동일한 위치 / LTE를 통한 10회의 연속 TCP bulk download</ul><li>결과<ul><li>스마트워치 중앙 throughput : 29.9Mbps<li>스마트폰 중앙 throughput : 56.1Mbps</ul><li>예상 원인<ul><li>시계의 소형 form factor ( 안테나 크기 작아짐, tx/rx 전력 감소 )</ul></ul><li>But) 스마트워치 interface : 다른 device들이 WWAN측에서의 성능이 좋지 않은 경우, 공동 content 제공에 <strong>상당히 기여할 수 있음</strong></ul><li>잠재적 우려사항 : energy</ul><h3 id="4-do-existing-network-level-collaboration-schemes-suffice">4. Do Existing Network-level Collaboration Schemes Suffice?</h3><ul><li>기존 network-level 협업 scheme : 몇가지 한계점이 있음</ul><h5 id="a-lack-of-flexibility">A Lack of Flexibility</h5><ul><li>원하는 network-level 수준 협업 요구사항<ul><li>다양한 유형의 app을 지원할 수 있도록 유연해야함<li>mobile, network infrastructure에 대해 최소한의 변경을 요구</ul><li>kibbutz : app의 관점에서 tethering device는 <u>단순히 layer-3 router처럼 작동</u><ul><li>layer-4/5 에서 다양한 개선 및 정책을 유연하게 지원할 수 없음<li>tethering subsystem : OS/kernel과 결합 -&gt; 수정이나 확장이 어려움<ul><li>Android tethering은 많은 실질적 limit이 있음<ul><li>2개 이상의 device에 대한 tethering 지원하지 않음 -&gt; 최대 2개의 device에서 동작<li>WiFi/Bluetooth 중 하나만의 tethering 연결이 설정될 수 있음 -&gt; 원할한 handover 방해<li>carrier/device : tethering 기능을 잠그거나, tethering 기반 hotspot에 대해 제한된 data 요금제만을 제공</ul></ul></ul><li>PRISM : sender/receiver 모두에게 수정된 kerenl TCP stack, network의 custom PRISM proxy에 의존 -&gt; <strong>상당한 deployment overhead</strong><ul><li>WLAN architecture : WiFi Ad-hoc mode에 의존<ul><li>Android, iOS에 사용할 수 없음</ul></ul><li>COMBINE, MicroCast, Cool-Tether 등의 다른 scheme<ul><li>layer-5의 app을 수정해야함<li>server : network 협업을 위해 HTTP byte-range request를 지원해야함<li>일부는 특정 유형의 app traffic 전용으로 설계됨</ul></ul><h5 id="suboptimal-performance-due-to-fluctuating-network-conditions">Suboptimal Performance due to Fluctuating Network Conditions</h5><ul><li>kibbutz ( tethering 관점 )<ul><li>end-to-end path는 2가지 segment로 구성<ul><li>WLAN<li>WWAN ( 이쪽의 throughput은 변동이 있음 )</ul><li>WLAN측 성능 실험<ul><li>가시선(LoS) / 비가시선(NLoS)에 따라 physical distance가 달라지는 경우<li>phone -&gt; phone 으로의 data fetching에서의 WLAN throughput 측정</ul><li>결과<ul><li>WLAN throughput은 크게 달라짐<ul><li>WWAN throughput보다 낮은 경우가 많았음</ul><li>이기종 link 특성 + 복잡한 상호작용 =&gt; WLAN, WWAN이 매우 다른 성능 나타냄<ul><li>dynamic한 방식으로 <strong>bottleneck이 될 수 있음</strong></ul></ul><li>기본 tethering 매커니즘 : 단순한 layer-2/3 forwarding<ul><li>위의 이질성 + dynamic을 제대로 다룰 수 없음<li>tethering에서) 유효 data rate = WWAN, WLAN bandwidth의 최솟값<ul><li>WWAN, WLAN을 분리하는 device에서 data를 적절히 buffering한다면 높일 수 있음</ul></ul><li>scheduling 결정을 내릴 때) 기존 scheme : 특정 시간에서의 WWAN, WLAN 사이의 bottleneck link의 성능만을 고려<ul><li>workload 분산 최적화 X -&gt; multipath 성능 저하</ul></ul></ul><h5 id="excessive-energy-consumption">Excessive Energy Consumption</h5><ul><li>배터리 용량이 작은 wearable device 등에서의 문제점<li>tethering 방식에서 congestion control = end-to-end<ul><li>한쪽이 bottleneck이라면 다른 쪽의 bandwidth가 줄어듬<li>줄어든 만큼 radio-on 시간이 늘어남 -&gt; energy 소비 증가</ul><li>app layer에서 작동하는 해법 : HTTP byte-range request 사이에 idle network period를 두는 것</ul><h2 id="mpbond-design">MPBond Design</h2><ul><li>MPBond : user가 mobile device를 공동으로 사용, app에 투명한 방식으로 internet에 접근할 수 있음<ul><li>1개의 primary device / 여러개의 helper device ( 다중 primary도 있는 듯 )<li>client app ( file downloader, video streaming 등 ) : primary에서만 실행됨<li>app의 TCP traffic : MPBond에 의해 투명하게 차단됨<ul><li>primary의 자체 interface / forwarding이 있는 helper를 통해 전송되도록 schedule</ul><li>반대 방향 : MPBond 지원 remote server의 여러 subflow에 traffic 분산<ul><li>content는 primary에서 합쳐짐</ul><li>MPBond 지원 proxy 도입 : internet server로부터 <strong>완전히 투명해지기 위해</strong> 사용<ul><li>단일 path connection 설정</ul><li>server : MPBond를 지원하는 remote server, proxy<li>MPBond : primary, helper에 OS service로써 구현<ul><li>client측 app에서도 투명성 유지</ul></ul></ul><h3 id="1-subflow-management">1. Subflow management</h3><ul><li>MPBond subflow의 상위개념 : MPTCP와 유사<ul><li>예외점<ul><li>subflow가 다른 mobile device를 traverse<li>수신된 part를 합치기 위해 primary와 helper가 local data를 주고받아야함</ul><li><i>pipe</i> : primary &lt;-&gt; helper 사이의 data channel<li><i>HS-path</i> : helper &lt;-&gt; server 사이의 network path<li><i>PS-path</i> : primary &lt;-&gt; server 사이의 network path ( helper 존재 X )<li>end-to-end subflow : PS-path 또는 HS-path + pipe를 통과</ul><li>WiFi, Bluetooth 등의 wireless 기술 사용 : 여러 pipe 동시지원<ul><li>WLAN을 이용하여 helper를 WiFi AP 역할을 하는 primary에게 연결 or Bluetooth를 이용하여 helper를 primary에게 페어링하여 설정<li>scheduler : 동적으로 pipe를 고르거나 여러개를 사용하여 <strong>data rate를 높이려는 목적</strong><ul><li>여러 요소를 반영하여 적합한 pipe 선택</ul><li>pipe : 해체되거나 설정될 수 있음 ( MPTCP와 유사 )<ul><li>user TCP 연결과 느슨하게 결합되어짐<li>data 전송에 방해 없이 pipe 간에 migration할 수 있음</ul></ul><li>MPBond handshake 절차 : helper를 활용하는 primary &lt;-&gt; server 간의 subflow를 이용한 user TCP 연결을 설정 // MPTCP 방법을 따름<ul><li>helper와 조정하기 위해 pipe를 통한 추가 control message 사용<li>HS-path + pipe가 포함된 subflow의 경우, primary : INIT_MP_JOIN message 전송<ul><li>helper에게 client + server의 정보 제공</ul><li>MP_JOIN message : 2번째 subflow 설정<li>ACK으로 MP_OK message 전송</ul></ul><h5 id="error-handling">Error Handling</h5><ul><li>MPBond : MPTCP와 다르게, pipe failure도 처리해주어야 함<ul><li>pipe가 고장나면 : subflow 해체, 보류중인 모든 data가 다른 subflow에 재주입<li>WWAN / WLAN link 오류로 인해 <strong>app data가 손실되는 일은 없을 것</strong></ul></ul><h3 id="2-buffer-management-and-helper-side-connection-split">2. Buffer Management and Helper-side Connection Split</h3><ul><li>MPBond : 양 endpoint에 buffer 유지<ul><li>network 변동 흡수<li>subflow의 이기종 특성 수용</ul><li>helper에도 buffer를 두었음<li>MPBond의 모든 subflow는 2개의 TCP flow로 분할됨<ul><li>primary &lt;-&gt; helper flow : pipe를 덮음<li>helper &lt;-&gt; server flow : HS-path를 덮음</ul><li>helper가 관여했다면, WWAN과 WLAN은 매우 다른 link 특성을 보임<ul><li>TCP 분할 : TCP control loop를 줄임 =&gt; 이 상황에서의 성능 향상<li>두 flow 사이에 <strong>buffer를 설정할 수 있음</strong><ul><li>subflow의 bottleneck 변화로 인한 부정적 성능 완화<li>primary와 helper가 가까워져 $Th_{pipe}&gt;Th_{HS}$로 되는 경우 : helper에 buffer를 설치 =&gt; $Th_{pipe}$의 크기만큼 data 전달 가능 ( <strong>더 빠른 data 전송</strong> )</ul></ul></ul><h3 id="3-pipe-aware-multipath-scheduler">3. Pipe-aware Multipath Scheduler</h3><ul><li>scheduler : traffic을 여러 path로 distribute하는 방법 결정<ul><li>wireless 상황에서의 개선 연구는 많았지만, <u>MPBond 적용에는 문제점이 있음</u><ul><li>대부분의 기존 mobile multipath scheduler : 2개의 path만을 다룸 ( WiFi, cellular )<ul><li>MPBond가 처리하는 multipath로써의 확장 불가</ul><li>이전에는 pipe에 대한 연구가 없음</ul></ul><li><strong>Pipe-aware Multipath Scheduler</strong> ( PAMS ) 개발<ul><li>기존과 다른 차이점<ul><li>subflow를 임의 개수만큼 scheduling 가능<li>scheduling에 MPBond의 TCP splitting, helper측 buffering 고려</ul><li>다양한 app에서 사용될 수 있음 ( data chunk 사용, <u>가능한 빠르게 전송해야함</u> )<ul><li>file 전송<li>video-on-demand<li>web browsing<li>cloud 동기화</ul><li>다른 유형의 traffic pattern = <i>real-time data streaming</i><ul><li>live video streaming<li>low-latency game</ul><li>위의 app들에 대한 multipath의 이점<ul><li>scheduling 알고리즘을 latency-favoring으로 전환해야함<li>multipath를 무작정 사용하면 QoE 패널티 발생</ul><li><strong>이 논문에서는 latency에 민감한 traffic을 위한 scheduler는 만들지 않음</strong><ul><li>사용하기 쉬운 interface를 통해 정책을 지정할 수 있도록 하여 handle<ul><li>latency에 민감한 traffic은 단일 경로를 사용한다<li>잠재적인 latency 팽창을 막기 위해, 우선순위를 높인다</ul></ul></ul></ul><h4 id="minrtt-considered-harmful">MinRTT Considered Harmful</h4><ul><li><p>기본 MinRTT scheduler 직접 적용하여 성능문제 시연</p><ul><li><p>primary : 2개의 subflow 설정</p><ul><li>근처 server로 직접 가는 flow / helper를 통해서 가는 flow</ul><li><p>각 link의 bandwidth</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">Downlink<th style="text-align: center">Bandwidth<tbody><tr><td style="text-align: center">PS-path<td style="text-align: center">8Mbps<tr><td style="text-align: center">HS-path<td style="text-align: center">10Mbps<tr><td style="text-align: center">pipe<td style="text-align: center">5Mbps</table></div><li><p>primary : MPBond를 이용하여 10MB file을 download</p><li><p>helper측 : buffer 존재 ( data를 저장 )</p><li><p>결과</p><ul><li>3곳의 bandwidth는 모두 사용되어짐 ( 긍정 )<li>subflow는 동시에 끝나지 않음 ( 부정 )<ul><li>helper를 통한 flow가 direct flow보다 4.5초 늦음<li>multipath 전송에서는, <u>subflow가 동시에 끝나야함</u><ul><li>최적의 download 속도를 위한 필수조건<li>이유 : 먼저 끝난 flow가 다른 flow를 <strong>지원</strong>할 수 있기 때문</ul></ul></ul></ul><li><p>불균형의 subflow 완료 원인 : scheduler가 PS-Path, HS-Path만을 모니터링</p><ul><li>TCP splitting 매커니즘과 downstream pipe를 알지 못함<li>두 subflow의 시간을 같게하는 것이 아닌, <strong>PS-Path/HS-Path의 완료 시간을 같게 맞춤</strong><li>HS-Path bandwidth &gt; pipe bandwidth이므로, helper측 buffer에 data 쌓임<ul><li>천천히 drain되며, 이것이 subflow 시간의 불균형 야기</ul></ul><li><p>subflow가 동시에 끝나도록 하는 방법 : subflow availability 조건을 수정</p><ul><li>helper subflow : HS-Path, pipe에 congestion window가 공간이 있는 경우 고려됨<ul><li>minRTT : 전자만을 고려</ul><li>수정을 실제로 적용하니 subflow가 거의 동시에 끝남<li>pipe에 사용할 수 있는 CWND 공간이 필요 =&gt; <strong>helper측의 buffering 기능 상실</strong> ( MPBond의 기능 상실 )<ul><li>PAMS의 주요 과제 : <u>**subflow 동시 완료를 달성하면서 helper측 buffering을 활성화**</u></ul></ul></ul><h4 id="deriving-the-pipe-aware-delay-pad">Deriving the Pipe-aware Delay (PAD)</h4><ul><li><p>downlink traffic을 위해 server에 있는 scheduler에 중점</p><li>end-to-end packet delay 계산<ul><li>주어진 시간 $T$, packet이 주어진 subflow에 schedule되었을 때, packet이 receiver에 도달하기까지 걸리는 시간?<li>단위<ul><li>$B_s$ / $B_p$ : $T$에서 server / helper 측에 buffering된 byte 크기<ul><li>TCP send buffer, user space buffer를 모두 포함</ul><li>$Th_{ps}$ / $Th_{hs}$ / $Th_p$ : PS-Path / HS-Path / pipe 에서의 측정 downlink throughput<li>$OWD_{ps}$ / $OWD_{hs}$ / $OWD_p$ : 각각 상응하는 path의 one-way delay</ul><li>direct subflow에서의 E2E delay = $OWD_{ps}+\frac{B_s}{TH_{ps}}$ ( prop delay와 que / trans delay 포함 )<li>helper가 존재하는 subflow : 2개의 buffer 포함<ul><li>server측 buffer를 drain하는 시간 $T_1=\frac{B_s}{Th_{hs}}$<li>$T_1$ 시간 뒤에, helper측의 buffer level을 $B_p$ -&gt; $B_p’$으로 변경<ul><li>$B_p’=max{(0,B_p-Th_pT_1+B_s)}$<li>$T_1$의 시간이 지난 뒤, helper측 buffer에 남아있는 byte = $B_p’$</ul><li>남은 buffered data를 제거하는 시간 $T_2=\frac{B_p’}{Th_p}$</ul><li>전체 E2E delay = $T_1+OWD_{hs}+T_2+OWD_p$</ul><li><p><strong>PAD 계산</strong> \(\begin{cases} OWD_{ps}+\frac{B_s}{Th_{ps}},&amp;\text{if }i=1\\ OWD_{hs}+\frac{B_s+B_p}{Th_p}+OWD_{p},&amp;\text{if }i&gt;1,\frac{B_p}{B_s}+1&gt;\frac{Th_p}{Th_{hs}}\\ OWD_{hs}+\frac{B_s}{Th_{hs}}+OWD_{p},&amp;\text{if }i&gt;1,\frac{B_p}{B_s}+1≤\frac{Th_p}{Th_{hs}} \end{cases}\)</p><ul><li>$i$ = subflow의 index ( $i=1$이라면 direct subflow )<li>$Th_{ps}$ / $Th_{hs}$ / $Th_p$ = 상응하는 path의 CWND와 RTT 사이의 ratio에 대한 <i>exponential weighted moving average</i>를 이용하여 추정<li>실제로 $OWD$ 측정이 어렵다면, 근사값 $RTT / 2$를 사용<li>2번째 식, 3번째 식은 $B_p’&gt;0$, $B_p’≤0$인 경우로 나눠진 경우</ul></ul><h4 id="the-pams-algorithm">The PAMS Algorithm</h4><ul><li><p>PAD : <strong>subflow에서의 E2E delay 추정치 제공</strong></p><ul><li>이것을 이용하여 scheduling을 결정해야함</ul><li><p>가능한 방법 : minRTT -&gt; minPAD로 수정하는 것</p><ul><li>subflow가 idle인 한 최소 PAD로 subflow를 선택하는 것<li>subflow가 idle하다 = PS-Path나 HS-Path의 CWND 공간이 비어있다<li>성능 : minRTT보다 뛰어남<li>단점 : HS-Path의 CWND 공간을 모두 점유하려고 시도<ul><li>subflow의 실제 capacity보다 더 많은 data를 scheduling할 수도 있음</ul></ul><li><p>scheduling을 <strong>전략적으로 연기</strong>하여 좀 더 현명한 scheduling 결정을 내릴 수 있음</p><ul><li>server <i>meta buffer</i>에 data가 많은 경우<ul><li>= schedule되지 않은 remained data가 많은 경우<li><strong>모든 bandwidth utilization을 향상시켜야 함</strong> : 모든 subflow를 busy 상태로 유지<li>PAMS : minPAD 적용<ul><li>idle subflow가 있다면 최소 PAD를 가진 subflow를 즉시 고르고, busy 상태로 전환</ul></ul><li>server <i>meta buffer</i>에 data가 적은 경우<ul><li><strong>latency 낮추기 + 동시 subflow 완료가 더 중요</strong><li>PAMS : idle subflow가 있더라도, latency를 줄이지 못한다면 skip</ul><li>단어<ul><li><i>meta buffer</i> : 아직 schedule되지 않은 data를 저장하는 buffer<li><i>per-subflow buffer</i> : 이미 subflow에 schedule된 data를 저장하는 buffer</ul></ul><li><p>PAMS 알고리즘 제작</p><pre><code class="language-pseudocode">Input: S = A set of N subflows. The algorithm executes when at least one subflow is idle, i.e., its PS-Path or HS-Path had empty space in CWND.
Output: Packet to transmit on a subflow [packet, subflow]
  
 1| packet &lt;- GetNextPacket();
 2| Th[1..N] &lt;- GetSubflowThroughput();
 3| PAD[1..N] &lt;- GetPipeAwareDelay();
 4| Idle &lt;- GetIdleSubflows();
 5| Busy &lt;- GetNonIdleSubflows();
 6| target &lt;- GetIdleSubflowWithMinRTT();
 7| Diff &lt;- 0;
 8| for each subflow i in Busy do
 9| 	if PAD[i] &lt; PAD[target] then
10| 		Diff += (PAD[target] - PAD[i]) * Th[i];
11| if Diff &gt; GetUntrasmittedSize() then
12| 	return NULL;
13| else
14| 	return [packet, target];
</code></pre><ul><li><i>Idle</i> / <i>Busy</i> : idle한 / non-idle한 subflow의 set<li><i>target</i> : 최소 PAD를 가진 idle subflow<li>8~14줄 : 이 algorithm의 핵심<ul><li><i>target</i> subflow가 완료되기 전에 현재의 busy subflows들을 통해 <strong>meta buffer의 모든 예약된 byte를 전달할 수 있는지의 여부</strong> 판별<li>busy subflow $i$에 대하여, buffer된 data는 PAD[i] 단위의 시간만큼 drain<ul><li>target subflow가 완료되기 전에 scheduling되지 않은 추가 data를 전달할 수 있는 여유시간 = PAD[target] - PAD[i]</ul><li>Th[i] : $i&gt;1$인 경우, HS-Path와 pipe throughput의 최솟값<ul><li>$i=1$인 경우는 direct path ( PS-Path ) 라서인가?</ul><li>Di$ff$ : target subflow 완료 전에, 모든 busy subflow들로 전달할 수 있는 schedule되지 않은 byte 크기<ul><li>Di$ff$ &gt; 현재 schedule되지 않은 byte 크기라면 : <u>현재 packet의 scheduling을 연기</u>, 이후에 현재 busy subflow를 통해 예약되도록 함<ul><li>전송시간 단축 효과<li>subflow 동시 완료 용이</ul><li>그렇지 않다면, <u>target subflow에 packet을 바로 scheduling</u><ul><li>bandwidth utilization을 높이는 효과</ul></ul></ul><li>이 알고리즘은 <strong>downlink traffic을 위해 만들어짐</strong><ul><li>uplink traffic에 대한 scheduler도 개념적으로 유사한 방법으로 개발</ul></ul></ul><h4 id="data-reinjection">Data Reinjection</h4><ul><li>reinjection : 이미 subflow $A$에 schedule된 data가 subflow $B$에 재주입되는 매커니즘<ul><li>$A$의 예기치 않은 성능 저하하는 경우<li>$B$의 capacity가 갑자기 증가하는 경우</ul><li>MPTCP : 보수적이고 고정적인 reinjection 정책<ul><li>관련 subflow가 제거되는 경우<li>receiver buffer가 꽉 찬 경우</ul><li>MPBond : 여러 device, 이기종 network, helper측 buffering 등에 의해 <strong>network 성능이 dynamic하고 변동이 심함</strong><ul><li><u>더 현명한 reinjection 결정이 필요</u></ul><li>MPBond reinjection scheme<ul><li>schedule되지 않은 byte가 없는 경우 + $\frac{maxPAD-minPAD}{minPAD}&gt;η$인 경우<li>$minPAD$ / $maxPAD$ : 모든 subflow들 중에서 최소 / 최대 PAD<li>$η$ : parameter<ul><li>reinjection의 공격성 결정<li>η이 줄어들면 -&gt; bandwidth utilization이 증가 / 더 자주 reinjection 발생<li>경험에 의거하여 20%로 설정해두고 진행</ul><li>근거<ul><li>PAMS가 모든 subflow 동시 완료를 위해 subflow의 buffer level ( $B_p$, $B_s$ ) 를 암시적으로 조정하므로, <strong>모든 subflow의 PAD는 이상적으로는 유사해야함</strong><ul><li>특정 subflow의 PAD가 너무 높거나 낮아지면 -&gt; network 성능의 심한 변동 유발<li>이 경우 <u>subflow의 balancing을 위해 reinjection 실행</u></ul></ul></ul><li>MPBond : reinjection이 trigger되면 maxPAD의 subflow -&gt; meta buffer로 $r$개의 ACK되지 않은, 가장 큰 sequence 번호를 가진 byte까지 이동<ul><li>$r=(maxPAD-minPAD)\times B$<ul><li>$B$ : maxPAD를 가진 subflow에서의 effective throughput<li>$r$ : PAD 관점에서, slow subflow가 the fastest subflow를 따라잡을 수 있는 방식으로 결정</ul><li>$r$만큼의 “재호출된” byte : PAMS에 의해 다시 schedule</ul></ul><h3 id="4-userapp-interfaces-and-policy-engine">4. User/App Interfaces and Policy Engine</h3><ul><li>MPBond : 2가지 type의 interface 제공 ( user / app developer )<li>primary에 console이 내장되어있음 : user가 여러 상황을 선택할 수 있음<ul><li>helper와의 pair / unpair<li>pipe 관리<li>MPBond를 사용하기 위한 app permission 주기<li>device의 runtime 상태를 monitor<li>다양한 policy 구성</ul><li>API 제공 : 3rd-party app이 프로그래밍적으로 MPBond의 service를 이용할 수 있도록 함<ul><li>device / pipe 관리<li>device / pipe 상태 query<li>pipe 구성 변경 등과 같은 중요한 event의 callback 기능<li>app data chunk의 경계 표시<ul><li><i>GetUntransmittedSize()</i> : 기본적으로 meta buffer에서 전송할 data의 총 크기를 반환<li>developer : app 계층 data chunk를 선택적으로 정의하여 현재 data chunk의 남은 byte를 반환하도록 할 수 있음<ul><li>meta buffer 전부 보내는 것보다 <strong>각 data chunk의 전달이 빨라짐</strong></ul></ul></ul><li>API 사용은 선택사항<ul><li>MPBond : app에 대해 완전 투명성<li>API는 MPBond에 대한 보다 세분화된 manipulation, 상세한 monitoring 제공<ul><li>Ex) data rate에 따라 bandwidth가 다른 pipe 사이로 dynamic하게 switch하여 <u>QoE 요구사항을 충족하면서 energy 사용을 줄임</u></ul></ul><li>MPBond : user에게 다양한 policy 유연하게 구성 가능<ul><li>prototype이 지원하는 policy<ul><li>각 app에 대한 whitelist<ul><li>각 app에 대한 permission을 부여해야함<li>app이 MPBond를 이용해 접근할 수 있는 device/pipe set을 구성해야함<ul><li>일회성 작업<li>뛰어난 유연성, 보안 강화</ul></ul><li>resource 사용량<ul><li>MPBond : device를 비활성화할 수 있음<ul><li>배터리 수준이 threshold 미만으로 떨어진 경우<li>cellular 사용량이 사전 정의한 cap에 도달한 경우</ul></ul><li>우선순위 지정<ul><li>user : 특정 app에 대한 우선순위를 지정하는 rule을 구성할 수 있음</ul></ul></ul></ul><h4 id="dual-mode-in-mpbond">Dual Mode in MPBond</h4><ul><li>MPBond : device가 primary / helper의 이중 역할을 가질 수 있도록 함<ul><li><strong>다중 primary 공존 가능</strong><li><i>dual mode</i> : primary device가 다른 시간대에 traffic을 생성하는 경우, <u>협업 device들이 집단 bandwidth를 더 잘 활용</u>할 수 있도록 함<li>예시 : 2개의 device로 각각 서로 다른 DASH video를 보는 경우<ul><li>각 device의 개별 자체로는 충분한 bandwidth를 지원하지 못할 수 있음<li>각 device : pairing하여 dual mode 실행<ul><li>자신이 primary로 video를 받으면서, <strong>다른 device에게 content를 전달하는 helper의 역할 수행</strong></ul><li>2개의 device : video chunk를 동시에 가져오지 않음 -&gt; <strong>다른 device가 가져오는 video chunk와 bandwidth 경쟁을 벌일 가능성이 적은</strong> 2개의 subflow로 download 가능<li>각 device의 QoE가 개선됨</ul></ul><li>prototype : 동일 device에서 primary / helper 등으로 여러 독립적인 MPBond instance를 실행함으로써 dual mode 실현<ul><li>한계 : 각 MPBond instance가 독립적인 schedule 결정<ul><li>network 상태, traffic 패턴에 대한 global view가 없기 때문에, 차선책이 될 수는 있음<li>모든 MPBond instance를 조정하는 “global manager”의 도입으로 해결 가능 ( 아직 구현되지 않음 )</ul></ul></ul><h2 id="implementation">Implementation</h2><ul><li>상용 스마트폰, wear OS에 구현<li>C/C++ 사용하여 multipath TCP proxy 구현<ul><li>MPTCP를 지원하지 않는 상용 internet server, middlebox 등에서의 실제 평가를 하기 위함<li>8천줄의 C/C++, Java 코드 ( 기본 proxy system 제외 )<ul><li>GitHub에 공개되어있음</ul></ul><li>primary : 대부분의 logic이 MPBond server의 user space에 있음<ul><li>MPBond proxy (helper) 와의 Ps-Path (pipe) 연결 수립</ul><li>수정되지 않은 app을 지원해야함<ul><li><i>netfilter</i>를 이용한 <strong>경량 kernel module</strong> 구축<ul><li>netfilter : client app traffic을 MPBond service로 가로채고 redirect</ul></ul><li>WiFi pipe : primary / helper 간의 수명이 긴 TCP 연결로 구현<li>Bluetooth pipe : Android Bluetooth socket API를 이용하여 구현<ul><li>RFCOMM 연결 수립</ul><li>helper module : 배포하기 용이하도록 user space에 구현<ul><li>proxy ( primary ) 와의 HS-Path ( pipe ) 연결 수립</ul><li>각 subflow : 원형 큐 사용 -&gt; user space에서 packet을 buffering<ul><li>buffer : HS-Path, pipe의 kernel send/recv buffer와 함께 작동<li>성능, energy 이점 제공</ul><li>pipe : 많은 user TCP 연결이 multiplex되는 수명이 긴 data channel<ul><li>TCP 연결을 식별하기 위해 app payload 앞에 작은 header 붙임<ul><li>TCP 연결 ID<li>message 길이<li>sequence 번호</ul></ul><li>PAMS : MPBond proxy에 연결된 user space scheduling module<li>PS-Path / HS-Path 정보 : Linux의 <i>getsockopt</i> API를 통해 server로부터 얻을 수 있음<li>pipe throughput : primary에서 측정<ul><li>캡슐화된 control message를 통해 helper에게 전달</ul><li>유연한 interface들 구현 : proxy로 보낼 pipe의 정보, 시간 결정<li>prototyping하기 위해 out-of-band UDP channel 사용<ul><li>HS-Path / PS-Path의 return path를 통해 pipe 관련 정보 전달<li>나중에는 HS-Path / PS-Path ACK에 통합될 수 있는 TCP option으로 교체 예정</ul><li>user 정의 policy : 매 process마다 시행</ul><h2 id="evaluation">Evaluation</h2><ul><li>MPBond를 다양한 network, 다양한 device 설정 등에서 광범위하게 평가<ul><li>목적 : network-level 협업의 이점을 보여주기 위함</ul><li>micro-benchmark를 통해 MPBond의 주요 design 선택을 검토<li>최첨단 solution과의 정량적 비교<ul><li>kibbutz, COMBINE<li>network 성능, energy 소비, QoE 등을 평가<li>실제 LTE, WiFi network 상에서 스마트폰, 스마트워치 등으로 평가</ul></ul><h3 id="1-experimental-setup-and-methodology">1. Experimental Setup and Methodology</h3><ul><li>상용 Ubuntu 16.04 server에서 proxy 실행<ul><li>MPBond, tethering 기반 MPTCP를 사용하는 kibbutz를 모두 지원<li>4코어 3.6GHz CPU / 16GB 메모리<li>‘decoupled CUBIC’ congestion control 알고리즘 사용<ul><li>각 path가 TCP CUBIC을 독립적으로 시행</ul><li>server : file과 video content를 host<ul><li>proxy에 근접해 있음<li>proxy와의 path는 bandwidth가 높음 -&gt; E2E path의 bottleneck이 아님</ul></ul><li>COMBINE : proxy가 필요하지 않음<ul><li>여러 mobile device가 HTTP byte-range request를 server로 직접 전송<li>동일한 object의 서로 다른 범위의 chunk를 fetch<li>request : work-queue 알고리즘에 의해 schedule<ul><li>각 path의 chunk를 순차적으로 download<li>그 chunk들을 primary한테 반환</ul><li>기본적으로 256KB 크기의 chunk로 기본 크기를 정함<ul><li>소형 file의 download에는 더 작은 chunk 크기 ( 128KB, 64KB ) 로도 시도하며 최상의 성능을 기록</ul></ul><li>MPBond : PAMS 사용<li>사용한 mobile device<ul><li>Pixel 2 ( phone )<li>Nexus 6P ( phone )<li>LG Urbane 2 ( smartwatch )</ul><li>emulated / real network 두 조건 모두에서의 MPBond 평가<ul><li>network 상태를 emulate하기 위해, Linux <strong>tc</strong> ( traffic control ) 사용<ul><li>실제 WWAN, WLAN의 bandwidth로 조절<li>상용 wireless network에서의 latency dynamic을 캡처</ul></ul><li>다른 장소에서 실제 LTE를 이용한 실험<li>full-fledged energy model 사용 : battery의 영향력 이해 목적<ul><li>network 전송에 따른 energy 소비량 추정</ul></ul><h3 id="2-microbenchmarks">2. Microbenchmarks</h3><ul><li>Pixel 2 with T-Mobile ( primary )<li>Nexus 6P with AT&amp;T ( helper )</ul><h5 id="benefit-of-helper-side-connection-split">Benefit of Helper-side Connection Split</h5><ul><li><p>주요 design : HS-Path와 pipe를 helper의 buffer로 분리</p><ul><li>network 변동 흡수<li>이기종 subflow의 특성 수용</ul><li><p>kibbutz와의 비교 : MPBond의 energy 및 성능 영향 이해</p><ul><li>kibbutz : subflow에 대한 다양한 고정 scheduling ratio 사용<li>4MB의 $p$%는 PS-Path로, 나머지 $1-p$%는 HS-Path와 pipe로 전송<ul><li>offline에서 최적의 $p$의 값 도출 ( exhaustive searching 기법 )</ul></ul><li><p>안정된 network 상태에서의 비교 ( 초기상황 )</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">subflow<th style="text-align: center">bandwidth<tbody><tr><td style="text-align: center">PS-Path<td style="text-align: center">5Mbps<tr><td style="text-align: center">pipe<td style="text-align: center">5Mbps<tr><td style="text-align: center">HS-Path<td style="text-align: center">10Mbps</table></div><ul><li>kibbutz와의 비교 ( 고정 scheduling ratio 사용 )<ul><li>download 시간은 거의 동일 / energy 소비량 10~22% 줄임<ul><li>helper측 연결 분할 : HS-Path로의 전송이 pipe의 전송보다 빠르게 완료<li><strong>LTE 접속 시간이 단축</strong>되어 energy 소비 감소</ul></ul></ul><li><p>변하는 network 상태에서의 비교</p><ul><li>처음 상태는 위와 동일 / 2초 뒤 HS-Path의 bandwidth를 1Mbps로 변경<li>helper측의 연결 split이 유효하면, download 시간과 energy 소비량이 모두 감소<li>HS-Path에 더 많은 data가 schedule되어있고, bandwidth가 갑자기 떨어지는 경우 더 좋은 성능<ul><li>분할된 flow 사이의 buffer : network 상태의 변동 흡수</ul></ul></ul><h5 id="benefit-of-flexible-feedback">Benefit of Flexible Feedback</h5><ul><li>MPBond : HS-Path / PS-Path를 통해 pipe 정보를 공유<ul><li><p>간단하지만 효과적인 policy</p><li><p>해당 path에 data 전송이 있을 경우에 pipe 정보 전송</p><li><p><strong>“Flexible” 정책</strong>이라고 불림</p><ul><li><p>HS-Path만을 통해 pipe feedback을 전송하는 것과 비교</p><li><p>서로 다른 timing에 대한 평가</p><ul><li>HS-Path 또는 pipe에 data 전송이 있는 경우 ( “fixed-always” )<li>HS-Path에만 data 전송이 있는 경우 ( “fixed-on-demand” )</ul><li><p>실험 ( 4MB file download )</p><ul><li><p>처음 상황 ( 위와 동일 )</p><li><p>2초 뒤 : pipe의 bandwidth &lt;- 10Mbps</p></ul><li><p>결과</p><ul><li>fixed-always : HS-Path의 data 전송이 없는데도 정보 feedback 전송<ul><li><strong>helper의 radio를 항상 활성화</strong> ( energy 소비 높음 )</ul><li>fixed-on-demand : HS-Path의 data 전송이 있는 경우에만 feedback 전송<ul><li>energy 소비 문제를 완화했음<li>pipe 정보는 최신을 유지하지 못함 -&gt; <strong>성능 저하 발생</strong></ul><li>flexible : HS-Path의 data 전송이 없다면 PS-Path로 feedback 전송<ul><li>helper의 radio를 켜지 않아도 됨 -&gt; energy 소비 저하<li>pipe의 정보를 최신으로 유지할 수 있음 -&gt; 성능문제 해결</ul></ul></ul></ul></ul><h5 id="estimating-pipe-buffering">Estimating Pipe Buffering</h5><ul><li>PAMS : packet의 pipe buffering 시간 추정<ul><li>helper에 있는 buffered data, pipe throughput을 기준으로 측정<li>helper에 의해 발생하는 packet의 buffering delay를 직접 측정하지 않음</ul><li>실험 ( 4MB file download )<ul><li>안정된 network 상태 ( 위와 동일 )</ul><li>결과 ( 평균 소요시간 )<ul><li>PAMS의 방식 : 3.6초 소요<li>직접 buffering delay 측정 : 4.4초 소요<ul><li>scheduler : 항상 부정확한 측정 buffering delay를 수신<li>scheduling 결정이 차선으로 이루어지기 때문</ul></ul></ul><h5 id="reinjection-under-changing-network-condition">Reinjection Under Changing Network Condition</h5><ul><li>reinjection : 변화하는 network 상황에서의 download 시간을 줄이는 방법<li>실험 ( 4MB file download )<ul><li>초기 상황은 위와 동일<li>2초 뒤 : pipe의 bandwidth &lt;- 1Mbps</ul><li>결과<ul><li>reinjection 활성화 : 4.8초<li>reinjection 비활성화 : 9.7초</ul><li>pipe의 bandwidth가 낮아짐 -&gt; 동시 subflow 완료를 위해 pipe의 data가 PS-Path로 reinjection됨</ul><h3 id="3-stable-network-conditions">3. Stable Network Conditions</h3><ul><li><p>MPBond의 성능, energy 소비에 대한 평가 ( 안정된 network 상황 )</p><ul><li>workload : 512KB ~ 2MB 크기의 file download<li>mobile device 개수를 다양하게 실험 ( 1~3 )<li>MPBond-Naive와의 비교 ( PAMS 대신 기본 minRTT scheduler 사용 )<li>각 test : 20번의 download 반복 / 평균, 표준편차 기록<li>energy 계산할 때 : 포함된 모든 mobile device를 고려</ul><li><p>결과 ( 공통 network bandwidth 설정 )</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">path<th style="text-align: center">bandwidth<tbody><tr><td style="text-align: center">PS-Path<td style="text-align: center">8Mbps<tr><td style="text-align: center">HS-Path<td style="text-align: center">10Mbps<tr><td style="text-align: center">pipe<td style="text-align: center">5Mbps</table></div><ul><li><p>각 device 개수 / 다른 scheme에 해당하는 7개의 군집이 있음</p><li><p>kibbutz와의 비교</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">device 개수<th style="text-align: center">download 시간<th style="text-align: center">energy 소비<tbody><tr><td style="text-align: center">2<td style="text-align: center">5% ~ 11% 감소<td style="text-align: center">10% ~ 14% 감소<tr><td style="text-align: center">3<td style="text-align: center">25% ~ 30% 감소<td style="text-align: center">비슷</table></div><ul><li>kibbutz : 구조적 한계에 의해 3개 이상의 추가 device를 활용할 수 없음</ul><li><p>COMBINE과의 비교</p><ul><li><p>MPBond : download 시간, energy 소비에서 <strong>훨씬 더 높은 성능</strong></p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">device 개수<th style="text-align: center">download 시간<th style="text-align: center">energy 소비<tbody><tr><td style="text-align: center">2<td style="text-align: center">15% ~ 21%<td style="text-align: center">28% ~ 38%<tr><td style="text-align: center">3<td style="text-align: center">12% ~ 26%<td style="text-align: center">22% ~ 25%</table></div></ul><li><p>MPbond-Naive와의 비교</p><ul><li>energy 소비 비슷<li>성능 더 높음<ul><li>차선의 scheduling 결정 사용 : <strong>subflow 완료 불균형</strong></ul></ul><li><p>개선</p><ul><li>MPBond의 여러 design 선택에 기인<ul><li>Layer 4의 system 및 pipe 구현<li>helper측 연결 분할 및 buffer<li>신중하게 설계된 다중 scheduler</ul></ul></ul><li><p>총 energy 소비량 세분화</p><ul><li>MPBond-Naive : 실험에서 제외<li>결과<ul><li>더 많은 device를 사용할수록 energy 소비 증가<li>COMBINE : primary의 energy 소비마저 증가<ul><li>효율적인 방식으로 workload를 분배하지 못하는 좋지 못한 scheduler design</ul><li>MPBond : device를 많이 사용할수록 <strong>primary의 energy 소비가 줄어듬</strong><li>kibbutz와의 비교<ul><li>MPBond의 energy 향상 : 대부분 helper측에 있음<ul><li>radio 활성화 시간을 줄이는 buffering 전략</ul></ul></ul></ul><li><p>kibbutz / COMBINE과의 비교 ( 더 많은 bandwidth 조합 )</p><ul><li><p>2개의 device 사용</p><ul><li>Pixel 2 ( primary ) / Nexus 6P ( helper )<li>pipe bandwidth &lt;- 5Mbps</ul><li><p>PS-Path, HS-Path를 다르게 하며 kibbutz에 대항한 MPBond의 energy 향상 실험</p><li><p>결과</p><ul><li><p>MPBond : HS-Path의 bandwidth가 높고 PS-Path bandwidth가 낮을 때 최고의 energy 이점</p><ul><li><p>1Mbps의 PS-Path / 18Mbps의 HS-Path</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">file 크기<th style="text-align: center">energy 소비<tbody><tr><td style="text-align: center">512KB<td style="text-align: center">31% 감소<tr><td style="text-align: center">1MB<td style="text-align: center">37% 감소<tr><td style="text-align: center">2MB<td style="text-align: center">47% 감소</table></div><li><p>download 시간 : kibbutz보다 약간 더 빠름</p></ul><li><p>energy 절약 : 이기종 WWAN, WLAN link에서, 더 빠른 link의 radio-on time을 줄이는 <strong>helper측 buffering</strong>의 효과</p></ul><li><p>PS-Path의 bandwidth를 변화하며 COMBINE과의 비교</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">pipe<th style="text-align: center">bandwidth<tbody><tr><td style="text-align: center">PS-Path<td style="text-align: center">5 / 8 / 11 / 14Mbps<tr><td style="text-align: center">HS-Path<td style="text-align: center">10Mbps<tr><td style="text-align: center">pipe<td style="text-align: center">5Mbps</table></div><ul><li>MPBond : file download 시간을 14% ~ 46% 줄임<ul><li>24% ~ 57%의 energy 절감 실현<li><strong>pipe와 PS-Path 사이의 이질성이 증가하면 MPBond의 향상성이 더 커짐</strong></ul></ul></ul></ul><h3 id="4-varying-network-conditions">4. Varying Network Conditions</h3><ul><li><p>MPBond의 성능 평가 ( 변화하는 network 상태 )</p><ul><li><p>위의 WWAN / WLAN bandwidth profile 채택</p><li><p>결과</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">scheme<th style="text-align: center">download 시간<th style="text-align: center">energy 소비<tbody><tr><td style="text-align: center">kibbutz<td style="text-align: center">21% ~ 23% 단축<td style="text-align: center">18% ~ 25% 감소<tr><td style="text-align: center">COMBINE<td style="text-align: center">29% ~ 35% 단축<td style="text-align: center">16% ~ 23% 감소</table></div><li><p>MPBond : 아래의 이유로 변화하는 network 상태에서 높은 network 활용도 달성</p><ul><li>helper측 연결 split<li>vuffer 관리<li>PAMS scheduler</ul></ul></ul><h5 id="in-the-wild-experiments">In-the-wild Experiments</h5><ul><li><p>실제 환경에서 실험</p><ul><li><p>kibbutz와의 성능 평가 ( MPBond와 제일 유사 )</p><li><p>2개의 위치 / 1분간의 download / 10회 반복</p><li><p>100ms마다 순간 throughput 기록</p><li><p>결과</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">위치<th style="text-align: center">중앙 bandwidth<th style="text-align: center">byte당 energy<tbody><tr><td style="text-align: center">1<td style="text-align: center">13% 향상<td style="text-align: center">19% 향상<tr><td style="text-align: center">2<td style="text-align: center">23% 향상<td style="text-align: center">24% 향상</table></div><ul><li>낮은 throughput 기간을 많이 줄임 ( 5번째 백분위 수 throughput 90% 향상 )<ul><li>변동하는 WWAN / WLAN link capacity를 최대한 활용<ul><li>buffer 관리<li>helper측 연결 split</ul></ul></ul></ul></ul><h3 id="5-video-streaming-performance">5. Video Streaming Performance</h3><ul><li>지금까지의 실험의 workload : 대량 file download<li>mobile network traffic을 지배하는 video streaming에서의 <strong>QoE, energy 효율 개선</strong>에 도움이 되는지실험<ul><li>다양한 scheme이 video bit rate에 미치는 영향 연구<ul><li>Exoplayer 사용 / ABR video streaming</ul><li>3가지 video 설정<ul><li>B2 : 2초 segment 길이의 Big Buck Bunny<li>T2 : 2초 segment 길이의 Tears of Steel<li>T6 : 6초 segment 길이의 Tears of Steel<li>B : 46kbps ~ 4.2Mbps에 이르는 20 bitrate / T : 253kbps ~ 10Mbps에 이르는 9 bitrate<li>총 video 길이 -&gt; B : 596s / T : 734s</ul></ul><li>kibbutz와의 비교 ( 둘 다 video streaming app의 수정이 필요하지 않음 )<ul><li>비슷한 video bitrate / energy 소비 13% ~ 14% 줄임<li>3개의 device를 사용하는 경우 : T2 / T6에서 video bitrate를 118% 향상<ul><li>B2에서는 큰 변화 없음 ( 2개의 device로 최대 bitrate에 도달 가능 )<ul><li>device당 energy 소비량은 감소 ( 3번째 device의 도움 )</ul></ul><li>T2 / T6 : 2가지 관찰 결과 제공<ul><li>MPBond-Naive : 2개의 scheme보다 더 낮은 energy 소비량 / 낮은 video bitrate<li>MPBond : device 개수가 늘수록 bitrate 향상<ul><li>bulk download하는 것만큼 <strong>각 device의 energy 소비를 줄이지는 못함</strong><ul><li>더 높은 bitrate = 더 큰 video segment이기 때문<li>QoE와 data 사용량의 tradeoff</ul></ul></ul></ul></ul><h5 id="360-degree-video-streaming">360-degree Video Streaming</h5><ul><li>360º video streaming : 기존 video streaming보다 더 큰 bandwidth 필요 ( MPBond의 이상적인 활용 사례 )<li>실험에서 video bitrate : 64Mbps로 고정<ul><li>video player emilator 사용 ( 가지고 있는 device가 고화질 decode를 지원하지 않음 )<ul><li>video content를 rendering하지 않고 download</ul><li>video stall ratio ( 정지 시간 / video 길이 ) 를 QoE metric으로 사용<ul><li>단일 primary : 정지 비율 145%<li>helper 사용 : 27%<li>3개의 device 사용 : 3%<ul><li>현실에서 종종 변동하는 LTE : 360º video의 높은 bandwidth 요구량을 항상 충족하지 못함<li>2개 이상의 device를 지원하는 <strong>MPBond의 필요성</strong> 동기부여</ul></ul><li>device 개수를 1 ~ 3개로 다양하게 조정</ul></ul><h3 id="6-leveraging-the-dual-mode">6. Leveraging the Dual Mode</h3><ul><li>LTE 연결 ( T-Mobile / AT&amp;T ) 이 가능한 device ( Pixel 2 / Nexus 6P ) 를 휴대한 2명의 user 참여<ul><li>각 LTE의 bandwidth : 5Mbps로 제한<li>pipe : 조절되지 않음</ul><li>MPBond dual mode 향상성 확인 실험<ul><li>두 user가 동시에 작업 시행<ul><li>각 스마트폰 : 순차적 1MB chunk 요청<li>chunk 간격 시간 : 1 ~ 5초 사이의 랜덤으로 video streaming traffic을 emulate</ul><li>MPBond dual mode / MPBond 없이 각각 chunk download하는 시간 비교<ul><li>Pixel 2 : 32% 향상 / Nexus 6P : 29% 향상</ul></ul></ul><h3 id="7-indoor-applicability">7. Indoor Applicability</h3><ul><li><p>위의 실험 : MPBond의 주요 사용 사례에서 진행 ( 야외 cellular networking )</p><ul><li>WiFi infra가 존재하는 실내 환경에서의 실험 진행</ul><li><p>WiFi infra가 있다면, WiFi / LTE를 이용한 MPTCP가 bandwidth aggregation에 쉽게 적용될 수 있음</p><li><p>MPTCP와의 성능 비교 실험 ( 4MB file download )</p><ul><li><p>2곳의 indoor 장소에서 실험</p><ul><li>A 위치 : -51dBm의 좋은 평균 WiFi 신호 강도<li>B 위치 : -68dBm의 좋지 않은 평균 WiFi 신호 강도</ul><li><p>2개의 scheme에 대하여 성능 / cellular data 사용량 비교</p><ul><li>1번 scheme<ul><li>primary : MPBond<li>helper 존재<ul><li>PS-Path, HS-Path : LTE<li>pipe : WiFi</ul></ul><li>2번 scheme<ul><li>MPTCP : WiFi<li>primary : LTE</ul></ul><li><p>10회의 연속 실행</p><li><p>결과</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">scheme<th style="text-align: center">위치<th style="text-align: center">download 시간<tbody><tr><td style="text-align: center">1<td style="text-align: center">A<td style="text-align: center">1.5s<tr><td style="text-align: center"> <td style="text-align: center">B<td style="text-align: center">1.2s<tr><td style="text-align: center">2<td style="text-align: center">A<td style="text-align: center">1.0s<tr><td style="text-align: center"> <td style="text-align: center">B<td style="text-align: center">1.6s</table></div><ul><li>2번 scheme의 cellular data 사용량 : 1.6MB (A) / 3.3MB (B)</ul><ol><li>MPBond : scheme 2보다 더 많은 cellular data 사용량<li>WiFi 상태에 따라 scheme 2보다 <strong>성능이 좋을수도 (B) 안좋을수도 (A) 있음</strong></ol></ul><li><p>MPBond : WiFi 신호가 좋은 실내의 경우, <strong>context 정보를 활용하여 WiFi, LTE에 대한 일반 multipath인 scheme 2로 돌아갈 수 있음</strong></p><ul><li>scheme 사이의 자동 전환을 할 수 있는 상황 인식 framework는 구현되있지 않음</ul></ul><h3 id="8-system-overhead-and-energy-concerns">8. System Overhead and Energy Concerns</h3><ul><li>remote server에서 큰 file을 download할 때, primary와 helper의 CPU utilization 측정<ul><li>비교대상 : kibbutz<li>10회 실험 반복<li>=&gt; 평균 추가 CPU utilization은 primary / helper 모두 4%가 넘지 않음</ul><li>helper 역할을 할 때의 wearable device의 battery 방전 조사<ul><li>15분 분량의 video stream<li>완전히 충전된 LG Urbane 2 스마트워치 사용<li>10회 실험 반복<li>=&gt; 평균 7% 이하의 battery drop 보임<ul><li><strong>solution의 실현 가능성</strong></ul></ul><li><p>이전 eveluation section의 energy 측정 결과 : power model 기반 ( 실제 hardware tool이 아님 )</p><ul><li><p>model 부정확 등의 측정 오류를 이해하기 위해, <strong>상용 power monitor</strong> 사용하여 실제 energy 소비량 측정</p><li><p>Samsung S5를 helper로 사용 ( power monitor에 꽂을 수 있음 )</p><li><p>Pixel 2를 primary로 이용</p><li><p>workload : 4MB file download</p><li><p>network 상태</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">path<th style="text-align: center">bandwidth<tbody><tr><td style="text-align: center">PS-Path<td style="text-align: center">8Mbps<tr><td style="text-align: center">HS-Path<td style="text-align: center">10Mbps<tr><td style="text-align: center">pipe<td style="text-align: center">5Mbps</table></div><li><p>power monitor : MPBond / COMBINE 경우의 helper측 energy 소비량 측정</p><ul><li>제한된 power monitor 수<li>helper측 : 대개 덜 강력함 / energy가 제한적임 ( wearable )</ul><li><p>10회 실험 반복</p><li><p>결과</p><ul><li>helper측 energy 소비량 : 2.3J ( MPBond ) / 3.4J ( COMBINE )<ul><li>model에서 도출된 절대 energy number : 1.9J / 2.6J<li>오차범위 최대 24%</ul><li>model 기반 (27%), power monitor 기반 (32%) 상대 energy 절감 ( COMBINE에 비한 MPBond ) 차이 : 최대 5%까지 낮음</ul></ul></ul><h2 id="discussion">Discussion</h2><h5 id="mpbond-over-homogeneous-cellular-links">MPBond over Homogeneous Cellular Links</h5><ul><li>위 실험들 : 다양한 ISP에 연결하는 mobile device로 수행됨<ul><li>MPBond가 bandwidth aggregation에 이상적인 기회 제공</ul><li>MPBond의 primary / helper가 같은 cellular carrier를 사용하는 경우 ( AT&amp;T ) 에서의 실험<ul><li>주택가 / 1분 동안의 download / 단일 device ( Nexus 6P ) 와의 비교 / 10회 반복</ul><li>결과<ul><li>Nexus 6P의 평균 throughput : 10.1Mbps<li>MPBond의 평균 throughput : 15.1Mbps<ul><li>direct subflow : 8.2Mbps / indirect subflow : 6.9Mbps</ul><li>helper를 추가하여 primary의 throughput이 감소하더라도, <strong>전체 throughput에는 큰 이득이 있음</strong><ul><li>eNodeB가 항상 모든 resource block을 단일 UE에 할당하지 않기 때문<ul><li>scheduling 정책 / 다른 단일 device의 존재 등 원인</ul></ul></ul><li>MPBond : <strong>단일 device를 사용하는 것보다 더 좋은 throughput 제공</strong></ul><h5 id="mpbond-over-congested-networks">MPBond over Congested Networks</h5><ul><li>MPBond : 단일 / 여러 carrier에 연결된 단일 device를 사용하는 것보다 <u>wireless resource를 더 많이 공유</u><li>모든 사람이 MPBond를 사용할 때의 wireless spectrum의 혼잡이 생겼을 때의 상황?<ul><li><strong>zero-sum 상황</strong> : 모든 user가 동시에 여분의 bandwidth를 가질 수 없음<li>오늘날 Internet traffic은 급증함 -&gt; MPBond 사용에 미치는 영향은 제한적일 것<li>MPBond user : 합리적인 cost로 다른 MPBond user들 사이에서 원하는 share를 얻을 수 있도록 <strong>helper device 수를 구성 가능</strong></ul><li>이 문제는 애초에 mobilde multipath / multi-device network 계층 협업의 문제임</ul><h2 id="conclusion">Conclusion</h2><ul><li>MPBond : 효율적인 network 계층 협업 framework<ul><li>개발<ul><li>연결 매커니즘<li>buffer 관리<li>packet scheduling<li>정책 시행</ul><li>시연 / 평가 ( 성능 / energy 이점 )<ul><li>실제 mobile device / app / network</ul></ul></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/imes/'>IMES</a>, <a href='/categories/paper/'>paper</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/imes/" class="post-tag no-text-decoration" >IMES</a> <a href="/tags/paper/" class="post-tag no-text-decoration" >paper</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=MPBond: Efficient Network-level Collaboration Among Personal Mobile Devices - Joe2357&url=https://joe2357.github.io/posts/MPBond/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=MPBond: Efficient Network-level Collaboration Among Personal Mobile Devices - Joe2357&u=https://joe2357.github.io/posts/MPBond/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=MPBond: Efficient Network-level Collaboration Among Personal Mobile Devices - Joe2357&url=https://joe2357.github.io/posts/MPBond/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/SCPC-2021-Round-1/">SCPC 2021 1라운드 후기</a><li><a href="/posts/SCPC-2020-Round-1/">SCPC 2020 1라운드 후기</a><li><a href="/posts/728/">Codeforces Round #728 (Div. 2) 후기</a><li><a href="/posts/727/">Codeforces Round #727 (Div. 2) 후기</a><li><a href="/posts/726/">Codeforces Round #726 (Div. 2) 후기</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ps/">PS</a> <a class="post-tag" href="/tags/review/">Review</a> <a class="post-tag" href="/tags/codeforces/">Codeforces</a> <a class="post-tag" href="/tags/imes/">IMES</a> <a class="post-tag" href="/tags/paper/">paper</a> <a class="post-tag" href="/tags/scpc/">SCPC</a> <a class="post-tag" href="/tags/ds/">DS</a> <a class="post-tag" href="/tags/storage/">Storage</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/WebRTC/"><div class="card-body"> <span class="timeago small" > May 26 <i class="unloaded">2021-05-26T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Audio and Video Mixing Method to Enhance WebRTC</h3><div class="text-muted small"><p> 2021 / 7 / 21 IMES 세미나 Abstract WebRTC : 웹브라우저에 JavaScript API를 호출함으로써 P2P 라이브 스트리밍 제공 소수의 peer로 제한되는 프로토콜 ( 다중 peer들의 real-time 스트림을 mix하기 힘듬 / mix된 스트림을 많은 수의 audience에게 분배할 수...</p></div></div></a></div><div class="card"> <a href="/posts/PBE-CC/"><div class="card-body"> <span class="timeago small" > Nov 26, 2020 <i class="unloaded">2020-11-26T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>PBE-CC: Congestion Control via Endpoint-Centric, Physical-Layer Bandwidth Measurement</h3><div class="text-muted small"><p> 2021 / 1 / 20 IMES 세미나 Abstract cellular network는 복잡해지고 과밀되어짐 delay, jitter 등의 문제 발생 PBE-CC : sender가 정확하고 급격하게 반응할 수 있도록 하는 최신 5G radio 혁신 기반 congestion control 알고리즘 ...</p></div></div></a></div><div class="card"> <a href="/posts/Edge-Assisted-Real-time-Object-Detection-for-MAR/"><div class="card-body"> <span class="timeago small" > Feb 17 <i class="unloaded">2021-02-17T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Edge Assisted Real-time Object Detection for Mobile Augmented Reality</h3><div class="text-muted small"><p> 2021 / 3 / 18 IMES 세미나 Abstract 대부분의 AR/MR : 주변 환경의 3D 형상을 이해할 수 있음 단점 : 현실의 복잡한 물체 탐지, 분류하는 능력 부족 해결 방법 : CNN에서 기능을 활성화할 수 있음 단점 : mobile device에서 대규모 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/695/" class="btn btn-outline-primary" prompt="Older"><p>Codeforces Round #695 (Div. 2) 후기</p></a> <a href="/posts/698/" class="btn btn-outline-primary" prompt="Newer"><p>Codeforces Round #698 (Div. 2) 후기</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/username">Joe2357</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/ps/">PS</a> <a class="post-tag" href="/tags/review/">Review</a> <a class="post-tag" href="/tags/codeforces/">Codeforces</a> <a class="post-tag" href="/tags/imes/">IMES</a> <a class="post-tag" href="/tags/paper/">paper</a> <a class="post-tag" href="/tags/scpc/">SCPC</a> <a class="post-tag" href="/tags/ds/">DS</a> <a class="post-tag" href="/tags/storage/">Storage</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://joe2357.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
