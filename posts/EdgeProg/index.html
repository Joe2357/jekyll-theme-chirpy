<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="EdgeProg: Edge-centric Programming for IoT Applications" /><meta name="author" content="Joe2357" /><meta property="og:locale" content="en_US" /><meta name="description" content="2021 / 4 / 29 IMES 세미나" /><meta property="og:description" content="2021 / 4 / 29 IMES 세미나" /><link rel="canonical" href="https://joe2357.github.io/posts/EdgeProg/" /><meta property="og:url" content="https://joe2357.github.io/posts/EdgeProg/" /><meta property="og:site_name" content="Joe2357" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-03-19T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="EdgeProg: Edge-centric Programming for IoT Applications" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Joe2357" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Joe2357"},"headline":"EdgeProg: Edge-centric Programming for IoT Applications","dateModified":"2021-04-29T11:30:26+09:00","datePublished":"2021-03-19T00:00:00+09:00","description":"2021 / 4 / 29 IMES 세미나","url":"https://joe2357.github.io/posts/EdgeProg/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://joe2357.github.io/posts/EdgeProg/"},"@context":"https://schema.org"}</script><title>EdgeProg: Edge-centric Programming for IoT Applications | Joe2357</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "AMS" } }, tex2jax: { inlineMath: [ ['$', '$'] ], displayMath: [ ['$$', '$$'] ], processEscapes: true, } }); MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) { alert("Math Processing Error: "+message[1]); }); MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) { alert("Math Processing Error: "+message[1]); }); </script> <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Joe2357</a></div><div class="site-subtitle font-italic">공부하는 블로그</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/Joe2357" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['deviljoe996','gachon.ac.kr'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>EdgeProg: Edge-centric Programming for IoT Applications</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>EdgeProg: Edge-centric Programming for IoT Applications</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Mar 19, 2021, 12:00 AM +0900" > Mar 19 <i class="unloaded">2021-03-19T00:00:00+09:00</i> </span> by <span class="author"> Joe2357 </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Apr 29, 2021, 11:30 AM +0900" > Apr 29 <i class="unloaded">2021-04-29T11:30:26+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7140 words">39 min</span></div></div><div class="post-content"><blockquote><p>2021 / 4 / 29 IMES 세미나</p></blockquote><h2 id="abstract">Abstract</h2><ul><li>IoT 앱 개발 : device side + server side에서의 분리된 프로그래밍 포함<ul><li>simple한 app에서는 충분한 방법<li><u>복잡한 app에서는 적절하지 않다</u> ( 복잡한 interaction / 집중적인 data processing )</ul><li>Edgeprog 제안 ( edge 중심적 프로그래밍 접근법 )<ul><li>user : 중앙집중식으로 app logic을 쓸 수 있음<ul><li>augmented if-this-then-that ( <strong>IFTTT</strong> ) syntax<li>가상 센서 매커니즘</ul><li>프로그램은 edge server에서 처리될 수 있음 ( 최적의 latency 달성 )<ul><li>실제 app code 자동으로 생성<li>device code와 server code를 지능적으로 분할</ul><li>동적 linking / loading 사용<ul><li>start에서 app별 code를 실행하지 않는 다양한 IoT device에 device code를 배포</ul><li>결과 ( 최신 접근법과의 비교 )<ul><li>20.96%의 실행 latency 감소<li>79.41%의 code line 감소</ul></ul></ul><h2 id="introduction">Introduction</h2><ul><li>IoT 앱개발 : device측 + server측의 분리된 프로그래밍<ul><li>Ex) device 측에는 센서, server측에 분석을 위한 data를 전달하는 등<li>간단한 app 개발에는 효율적 / 복잡한 app 개발에는 적절하지 않음</ul></ul><h5 id="complex-interactions">Complex interactions</h5><ul><li><p>Ex) 문이 열릴 경우 센서가 감지하여 LED를 켜려고 함</p><li><p>기존 프로그래밍 스타일 : app logic이 다른 센서 node로 분산</p><ul><li>시스템의 복잡성 증가 / 관리성 저하</ul></ul><h5 id="intensive-data-processing">Intensive data processing</h5><ul><li>Ex) speech 인식 app 개발<li>방법<ul><li>모든 센서 data를 복잡한 인식 알고리즘을 돌리는 server로 전송<ul><li>과도한 에너지 소비 ( 많은 양의 trasmission )</ul><li>IoT device에서 인식 알고리즘 수행<ul><li>과도한 delay 유발 ( 연산 파워의 부족 )</ul></ul><li>separate programming : 적절한 프로그래밍 방법을 선택해야함</ul><hr /><ul><li>엣지컴퓨팅의 인기 증가에 따라 <u>다른 프로그래밍 접근법을</u> 제안<ul><li>다수의 IoT node : sensing / actuation ( 실행 ) 수행<li>각각 local edge로 연결됨 ( 복잡한 연산 수행 )<li>edge server : power suffly 존재 / energy 제약사항이 적음<li>edge computing : 적은 processing delay / 더 좋은 privacy 제공<li><strong>EdgeProg</strong> : 새로운 프로그래밍 스타일 / 시스템 구조<ul><li>IoT app 프로그래밍을 크게 단순화<li>전체 시스템의 효율 손실 없이 다양한 app에 대해 재프로그래밍될 수 있는 <u>일반적인 IoT system</u><li>개발자 : high-level 언어 사용<ul><li>전체 app logic + IoT app 통합</ul><li>프로그램이 edge server에서 처리될 수 있음<ul><li>실제 app code를 생성<li>device code / server code로 분할</ul><li><em>edge-centric</em> 접근법 : 프로그램이 edge에서 실행되어지는 듯한 효과<li>일반적인 IoT node : 처음부터 app별 code를 실행하지 않음<ul><li>app의 첫 실행에 IoT node의 메모리에 app별 code가 자동 load될 것</ul></ul><li>Challenge<ul><li>다중 device 상호작용 + data 집중적 연산을 지원하는 edge-centric 언어 설계 방법?<li>user-인식 프로그램을 분할하여 최적의 delay를 달성하는 방법?<li>이기종 sensor node가 device측 code를 동적으로 load하고, 효율적으로 실행할 수 있도록 하는 매커니즘 설계 방법?</ul><li>일관성 있는 언어 설계<ul><li>목적<ul><li>edge 중심 프로그래밍 지원<li>app 개발 프로세스 속도 향상</ul><li>다중 device 상호작용 지정<li>IFTTT 기반 언어 기반 / 확장<ul><li>목적<ul><li>표현력 높임<li>data 집약적 연산 채택</ul><li>가상 센서 사용<ul><li>머신러닝으로 자신들의 data 처리 로직 설계를 가속화</ul></ul></ul></ul><li>EdgeProg : 자동 코드 분할 수행<ul><li>각 device의 연산 능력을 완전히 활용<li>최적의 latency 달성<li>user가 작성한 프로그램 -&gt; data flow 그래프로 추출<li>partitioning 문제 -&gt; integer programming 문제로 공식화<li>최적의 partition을 얻기 위해 <code class="language-plaintext highlighter-rouge">lp_solve</code> 해결자 사용</ul><li>Contiki OS에서 구현<ul><li>플랫폼 교차지원<li>동적 linking / loading 기술 사용 -&gt; 런타임에 최적화된 실행파일 load 능력 구현<li>app 실행 중 app의 logic을 바꾸는 대안<ul><li>가상머신 이용<li>스크립팅 언어 사용</ul><li>대안을 사용하지는 않을 예정 ( 동적 linking / loading에 비해 overhead가 상당 )</ul><li>구현 평가<ul><li>EdgeProg 언어 : 다양한 IoT app logic을 표현할 수 있음<ul><li>code line을 79.41% 줄일 수 있음</ul><li>최신 partitioning 시스템과의 비교<ul><li>평균 20.96% / 최대 99.05% 감소</ul><li>동적 linking / loading 기술 사용과 대안책을 사용할 때의 비교<ul><li>가상머신을 사용하는 경우 : 9.98X<li>스크립팅 언어를 사용하는 경우 : 6.37X</ul><li>프로파일링 메소드 정확도 평가<ul><li>85%+의 정확도</ul></ul><li>contribution 요약<ul><li>EdgeProg ( IoT app을 위한 <em>edge 중심적</em> 프로그래밍 시스템 ) 제안<ul><li>흩어진 app logic -&gt; 사용하기 쉬운 방법으로 logic을 표현할 수 있도록 함</ul><li>task의 makespan을 최소화하기 위해 code 분할 문제를 공식화<ul><li>분할 알고리즘 : 각 stage의 배치 최적화 ( 프로세싱 / 네트워크 latency를 모두 고려 )</ul><li>EdgeProg 개발 / 평가 ( 실제 app / 벤치마크 )<ul><li>최신 연구들과 비교하여 latency 감소 / line 감소</ul></ul></ul><h2 id="background-and-edgeprog-usage">Background and EdgeProg Usage</h2><h3 id="a-background">A. Background</h3><h5 id="dynamic-linking-and-loading-of-iot-devices">Dynamic linking and loading of IoT devices</h5><ul><li>IoT device의 over-the-air reprogramming 기술 중 하나 ( 과잉 재프로그래밍 )<ul><li>linking phase<ul><li>on-device reprogrammer : 파일의 구조화된 정보 -&gt; 실행 가능하고 link 가능한 파일 ( ELF ) / 그것들의 변형 ( CELF / SELF ) 로 파싱<li>ELF 파일의 data / text segment에 대해 ROM / RAM 등을 할당<li>재배치 수행 ( symbol table에서 발견되거나 ELF에서 재배치 정보를 사용하여 계산된 symbol의 실제 메모리 주소로 data 및 text segment를 패치 )</ul><li>loading phase<ul><li>text segment를 할당된 ROM에 write<li>data segment를 RAM에 복사<li>binary가 load되어짐 / 실행 준비 완료</ul></ul><li>대안들 ( 가상머신 / 부트로더 ) 와 비교하여 장점이 있음<ul><li>높은 장기간 효율성 ( 가상머신 code 대신 고유 code를 실행하기 때문 )<li>재부팅이 없는 update ( 에너지 효율 )</ul></ul><h5 id="virtual-sensor">Virtual sensor</h5><ul><li>다른 장소에 위치할 수 있는 실제 센서들로부터 감지한 데이터를 추상화하는 논리적 실체<li>전통적인 하드웨어 센서 : 물리적 특성의 raw 측정값만을 제공함<ul><li>수익성이 없음 ( 높은 level의 domain 의존 정보로 변환해야만 수익성이 생김 )<li>값진 data를 얻기 위해서는 여러 sensor들의 조정이 필요함 ( 온도 / 연기 센서로 화재위험 감지 )</ul><li>위의 한계점과 센서 data 처리를 유연하게 하기 위해 고안되어짐<li>여러 하드웨어 센서에서 감지된 data + 데이터 처리 알고리즘의 결합으로 일반적으로 물리적으로 측정할 수 없는 <u>간접 측정 / 이벤트 제공</u><li>EdgeProg : 기본 IFTTT 문법의 확장형 -&gt; 집중적인 data 처리를 하기 위한 사용하기 쉽고 표현적인 처리 제공</ul><h3 id="b-edgeprog-usage">B. EdgeProg Usage</h3><ul><li><p>Ex) <code class="language-plaintext highlighter-rouge">SmartHomeEnv</code></p><ul><li><p>2개의 센서 ( 온도 / 습도 ) data를 입력으로 받음</p><li><p>에어컨 / 제습기를 켤 수 있음 ( 2개의 input이 threshold를 넘길 경우 )</p><li><p>2개의 센서 : edge server와 무선 연결 ( 라즈베리 파이 등 )</p><li><p>전통적인 관점 : edge server에 주기적으로 센서값 전송하는 기능이 있는 app별 code로 미리 설치</p><ul><li>edge : reading값을 처리 / 미리 정의된 인터페이스 사용 -&gt; 센서와 상호작용</ul><li><p>EdgeProg 사용 : app별 logic 없이 “idle” 프로그램으로 미리 설치</p><ul><li>모든 app logic : 향상된 IFTTT 기반 언어로 구현<li>edge 서버에서 해석 / 처리되어짐</ul><li><p>예시</p><pre><code class="language-EdgeProg">Application SmartHomeEnv {
	Configuration { // device와 그들의 interface 선언
		TelosB A(TEMPERATURE);
		TelosB B(HUMIDITY);
		Edge E(turnOnAC, turnOnDryer);
	}
	Rule { // IFTTT를 따른 app별 login
		IF (A.TEMPERATURE &gt; 30 &amp;&amp; B.HUMIDITY &gt; 70)
			THEN (E.turnOnAC &amp;&amp; E.turnOnDryer)
	}
}
</code></pre><ul><li>edge 서버 : code를 자동으로 2개로 분할<ul><li>device측 component / edge측 component<li>device측 컴포넌트 : load 가능한 모듈로 컴파일 -&gt; 센서 node로 전송<li>한번 notice하면, “idle” 프로그램이 실행을 위해 app별 모듈을 동적으로 load할 수 있음</ul></ul></ul><li><p>핵심</p><ul><li>전체 app code를 자동으로 분할할 수 있음 -&gt; 실행성능 최적화<ul><li>전산집약적 IoT 작업에 필수적 ( 음성인식 / 영상감시 등 )<li>device에 code를 배치하는 것보다 작업에서 더 나은 성능을 보이는 경우, edge 측으로 code를 분할</ul></ul></ul><h2 id="edgeprog-overview">EdgeProg Overview</h2><h3 id="a-design-goals">A. Design Goals</h3><h5 id="edge-centric">Edge centric</h5><ul><li>개발 중에 app logic을 조각으로 분해할 필요가 없도록 edge-centric한 접근법 제공</ul><h5 id="latency-aware">Latency-aware</h5><ul><li>edge device에 조정된 app에게 적시성은 치명적인 성능 문제와 직결<li>EdgeProg : 주어진 input에 대한 시간최적 solution을 제공하는 능력이 필요</ul><h5 id="automatic">Automatic</h5><ul><li>EdgeProg : user의 idea를 표현하는데 아무런 이득이 없는 세부사항을 구상 / app 개발을 단순화하고 가속화하기 위해 인간을 loop에서 제거한다는 것을 의미</ul><h3 id="b-edgeprog-architecture">B. EdgeProg Architecture</h3><ul><li>user : edge-centric한 app code를 바로 작성할 수 있음<ul><li>분산된 프로그래밍 스타일 / 각 stage에서 물리적 placement 등을 고려하지 않아도 됨</ul><li>system : user code를 input으로 받음<ul><li>전처리, feed -&gt; <em>code partitioner</em>로 전달</ul><li>code partitioner : 각 device의 <em>time profile</em> + 파티셔닝 알고리즘에 의해 각 stage에서의 최적의 파티션 / placement를 탐색<li><em>code generator</em> : user가 작성한 code 전처리 -&gt; 컴파일이 가능한 code로 변환<ul><li><em>code compiler</em> : 실행 가능 / load 가능한 binary로 변환</ul><li>실행파일 : 공중을 통해서 배포 / edge device에 배치</ul><h5 id="user-input">User Input</h5><ul><li>EdgeProg 프로그래밍 모델에 의해 작성되어짐<ul><li><code class="language-plaintext highlighter-rouge">interface</code>에 의해 지정된 device에서 제공하는 actuator<li><code class="language-plaintext highlighter-rouge">implementation</code>에 의해 지정된 가상 센서의 출력<li>위를 이용하여 app logic을 지정하는 rule 개념 중심으로</ul></ul><h5 id="code-partitioner">Code Partitioner</h5><ul><li>user input app에 대한 최적의 파티션 제공</ul><h5 id="time-profiler">Time profiler</h5><ul><li>각 스테이지의 시간 정보 : code partitioner의 중요한 input<li>profiling phase : 다른 플랫폼에서의 실행 시간 얻음<li>low-end 센서 node : cycle-accurate 시뮬레이터 사용<ul><li><code class="language-plaintext highlighter-rouge">MSPsim</code> ( MSP430 기반 node ( TelosB ) )<li><code class="language-plaintext highlighter-rouge">Avrora</code> ( AVR 기반 node ( MicaZ ) )<li>timing 정보를 얻기 위함</ul><li>high-end 센서 node : low-end보다 정확도가 낮음<ul><li>원인 : 자동 frequency scaling 전략 사용 -&gt; 시뮬레이터의 정확도 감소</ul><li>real device에서 raw timing data를 모으는 것은 좋지 않음, 실현 불가능함<ul><li>edge server의 하드웨어 interface의 한계<li>high-end device를 profiling하기 위해 <code class="language-plaintext highlighter-rouge">gem5</code>이라는 cycle-accurate 시뮬레이서 근접 방법 채택</ul></ul><h5 id="network-profiler">Network Profiler</h5><ul><li>네트워크 상태 : 파티션에 공급되는 주요 metric<ul><li>deploy되었을 때 network 상태 파악 방법 : M-SVR 알고리즘 사용<ul><li>Multiple-output support vector regression : 간격 시퀀스에서의 미래 네트워크 상태를 나타내는 예측 시퀀스를 생성<li>loading agent에서 0.1Hz로 샘플링된 대역폭 / RSSI 등이 fed되어짐<li>predictor : 미래 throughput / 패킷당 전송시간 추정치 출력 ( 추가 세분화 시간 계산 목적 )</ul><li>예측 알고리즘 : 시스템의 블랙박스 역할<ul><li>다른 예측 알고리즘 사용해도 괜찮음</ul></ul></ul><h5 id="code-generator">Code Generator</h5><ul><li>생성된 최선의 파티션 : code generator에서 진행되어짐<li>high-level의 EdgeProg 언어 -&gt; 컴파일 가능한 C code로 변환</ul><h5 id="code-compiler">Code Compiler</h5><ul><li>받은 code -&gt; 실행가능 파일로 변환 ( target flatform에 맞춰서 )<li>이후 배포 시작<li>현재 4개의 플랫폼 / 4개의 MCU 구조 지원 ( ATMega, MSP, ARM, x86 )</ul><h5 id="loading-agent">Loading Agent</h5><ul><li>시스템 초기 : loading agent를 제외하고 node에서 실행되는 app별 logic이 없음<li>edge와 주기적 통신 : 새로 load 가능한 app을 위함<li>app이 컴파일 이후 배포되기 시작할 때, 목적지에 있는 loading agent : 실행 가능 감지 / 검증 / 수신<ul><li>이후 동적으로 실행</ul></ul><h2 id="system-design">System Design</h2><h4 id="a-edgeprog-programming-language">A. EdgeProg Programming Language</h4><ul><li>EdgeProg : DSL 언어 수용 ( 개발자들이 app 개발할 때 사용하는 언어 )<ul><li>흩어진 프로그래밍 스타일의 문제점 해소 / app 개발 프로세스 가속 목적<li>Rule-based Domain-Specific Language<li>app : 3개의 파트로 구성되어짐<ul><li>configuration / implementation / rule</ul></ul></ul><h5 id="edge-centric-programming-model">Edge-centric programming model</h5><ul><li>edgeprog : edge 중심 설계 목표<ul><li>implementation의 세부사항보다 <u>global behavior에 user를 집중시켜야함</u><li>개발자 : <code class="language-plaintext highlighter-rouge">Rule</code> 키워드 활용 -&gt; 전체 app logic을 중심으로 app 구성 가능</ul><li>여러 DSL이 있음 : sensornet 연구에서 개발자가 macro-programming model에 집중할 수 있음<ul><li>최근에는 기존 연구가 좋지 않음 ( app 이동성, 작동 부족 등에 대한 제약조건 )</ul><li>IFTTT 프로그래밍 기법 : 다른 연구들에 비해 단순 / 효율적 ( hight-level app logic을 표현할 때 )<ul><li>첨단 산업 솔루션으로 활용 중<li>edgeprog에서도 비슷한 문법 활용 : <strong>통일되고 명시적인 방식으로 자신의 아이디어 표현 가능</strong><li><code class="language-plaintext highlighter-rouge">Configuration</code>, <code class="language-plaintext highlighter-rouge">Implementation</code> 추가 : <code class="language-plaintext highlighter-rouge">Rule</code> 파트에서 사용될 구성요소의 세부 정의 / 사양 등 표현</ul></ul><h5 id="full-support-of-virtual-sensor">Full support of virtual sensor</h5><ul><li>요즘의 방대한 data 처리를 수용하기 위해 DSL를 <strong>가상 센서를 이용하여 강화</strong><ul><li>가상 센서 : 복잡한 data 처리 알고리즘을 표현하는 효율적인 접근법<ul><li>feature 추출 / 분류 2가지 단계로 구성</ul></ul><li>가상 센서 <code class="language-plaintext highlighter-rouge">VoiceRecog</code><ul><li>A.MIC 인터페이스 : 입력 음성 단편 생성<li>가상 센서 : 입력된 음성이 “open”인지 아닌지 인식<li>FE / ID 두 단계로 구성된 pipeline<ul><li>각 stage마다 <code class="language-plaintext highlighter-rouge">setModel()</code> 존재 ( 음성인식 지원 )</ul><li>17개의 data 처리 알고리즘 ( 12개의 추출 / 5개의 분류 )<li>FE / ID : 일반적인 pipeline 구성<ul><li>2개 이상의 여러 stage / 병렬 stage도 지원함</ul></ul><li>green 개발자 : 어떤 센서가 어떤 예상 출력과 어떤 관련이 있는지 모름 -&gt; 복잡성이 높음<ul><li>완화 방법 : <em>inference-agnostic</em> 가상 센서<ul><li>관련 센서 set와 가상 센서 예상 출력 제공</ul></ul><li>edgeprog : 처음에 샘플 app을 생성<ul><li>개발자 : 충분한 training data를 얻기 위해 원하는 event를 기록해야함<li>edgeprog : 입력 센서 &lt;-&gt; 기록된 event 간의 관계를 반영하는 모델 훈련<li>이후 다른 가상 센서와 비슷하게 분할 / 보급</ul></ul><h5 id="explicit-data-flow">Explicit data flow</h5><ul><li>약 45%의 code line이 data flow 구축 / 상호작용을 위해 작성되어짐<ul><li>상당한 양 / 프로젝트의 복잡성 증가 원인</ul><li>여러 device 상호작용 : 네트워크 패킷 구성에서 생기는 data flow를 더 복잡하게 함<li>일반적인 IoT app에서의 data flow : 센서 data로부터 생성 / 시작 ( 여러 알고리즘으로부터 생성 )<ul><li>database에 저장되거나, 실행 IoT 노드로 command-back<li>So, 이 3 단계에 data flow를 명시적으로 제작</ul><li>개발자 : data 및 사용 가능한 action을 인터페이스로 지정<ul><li>사용 가능한 인터페이스 : 공급업체 / prototype 개발자에 의해 결정되어짐</ul><li>데이터 처리 목적 -&gt; 가상 센서, rule : 인터페이스 직접 사용 / 호출 -&gt; 통일적이고 명시적인 data flow 초래</ul><h4 id="b-code-partitioning">B. Code Partitioning</h4><ul><li>code 분할 subsystem 목적 : 적절한 stage로의 user input 분리 / 각 stage마다 최선의 placement 얻기<ul><li>사용자 input app -&gt; 연산 stage를 나타내는 logic block으로의 전처리<li>rule의 data flow 그래프 생성 ( app logic, stage 의존도 파악 목적 )<li>latency-ware : edgeprog의 설계 목적 중 하나<ul><li>latency 최소화 문제 공식화 / 각 stage의 최적 배치를 찾는 solver 사용</ul></ul><li>파티셔닝 알고리즘 핵심 : 연산을 data source와 가깝게 밀어넣음 / 각 device의 연산능력을 최대한 사용하여 latency 감소 달성<ul><li>edgeprog : 좋은 연산-전송 tradeoff를 달성하는 최적의 placement 찾을 수 있음</ul></ul><h5 id="logic-blocks-and-data-flow-graph-construction">Logic blocks and data flow graph construction</h5><ul><li>더 이상의 구현 / 최적화가 불가능한 2가지 차이가 있음 ( 이 프로그래밍 언어의 compact한 특성 )<ul><li>일부 stage : 암시적으로 정의되고, app에서 사용될 수 있음<ul><li><code class="language-plaintext highlighter-rouge">rule</code> stage에서 필요하지만, 그것이 app에서 구상되어지는 경우가 있음</ul><li>토플로지 정보 : 전체 최적화에 필요 ( 그런데 이것도 app에서 암시되어짐 )</ul><li>차이 해소 방법 : node가 logic block으로 표시되는 app의 data flow graph를 구성<ul><li>logic block : app의 독립적인 building block<ul><li>code 생성을 위한 input source 포함해야함<li>배치 / 알고리즘 / 시간 profiling에 필요한 파라미터 등의 정보 포함해야함<li>tuple &lt;<em>functionality</em>, <em>placement</em>&gt;로 정의되어짐</ul><li><em>functionality</em><ul><li><code class="language-plaintext highlighter-rouge">SAMPLE</code>, <code class="language-plaintext highlighter-rouge">ACTUATE</code>, <code class="language-plaintext highlighter-rouge">CONJ</code> 의 tenet에서의 tasklet primitive 차용 ( 광범위한 data 수집 / 처리 작업을 위한 building block )<li>가상 센서 배치를 수용하기 위한 알고리즘 primitive 추가 ( GMM )<li>logic block의 data 소스 : primitive의 첫번째 argument로 선언되어짐</ul><li><em>placement</em><ul><li>2종류의 code block : <em>pinned</em> / <em>movable</em><ul><li>pinned : 물리적으로 구속된 기능<ul><li><code class="language-plaintext highlighter-rouge">SAMPLE</code> : device에 배치되어야만 함</ul><li>placement : 고정된 block에 고정되어짐<ul><li>logic block에서 해당 device 별칭 사용</ul><li>movable : 불확실성을 표기하기 위해 ? 같이 표시<ul><li>device / edge에 잠재적으로 배치됨</ul></ul></ul></ul><li>명시적으로 선언된 logic block 제외하고 일부 block : 완전그래프에서도 필요 / 사용자 app에서 암시적으로 그려짐<ul><li>내재된 block으로 data flow graph 완성하기 위해서는, <code class="language-plaintext highlighter-rouge">Rule</code>에서 정의된 모든 규칙을 아래와 같은 전략으로 분석<ul><li>IF-statement에서 가상 센서를 활용하는 조건에서, <code class="language-plaintext highlighter-rouge">Implementation</code> 부분 참조하여 stage pipeline 확보 / SAMPLE 블록 삽입<li>센서 값만을 비교하는 조건에서는, 2개의 stage로 변환 ( SAMPLE, CMP )<li>CONJ 블록 : IF-statement에서 모든 conjunction 표기<li>Then-statement에서의 각 action : 2개의 block으로 변환<ul><li>AUX : 보조 movable 블록 ( statement가 edge / local에서 실행될 것임을 나타냄 )<li>ACTUATE : 고정 블록 ( action을 나타냄 )</ul></ul><li>data flow graph : 유향 비순환 그래프로 나타내어질 것<ul><li>정점 : logic block<li>간선 : data flow가 있음을 나타냄</ul></ul></ul><h5 id="the-ilp-problem-for-optimal-partitioning">The ILP problem for optimal partitioning</h5><ul><li><p>data flow graph의 존재 : 최선의 파티셔닝 문제 -&gt; 수치 최적화 문제로 공식화 가능</p><ul><li>최선의 파티셔닝 결과 : logic block을 각각 가장 선호되는 연산 device에 할당하는 것<li>할당 결과 : 이진값 $X_{b_is_i}$로 표기 ( 1이면 할당 / 0이면 비할당 )</ul><li><p>이전에 있던 파티셔닝 알고리즘을 가져와서 사용 ( Wishbone )</p><ul><li><p>2가지 차이점에 의해 이곳에서 실현될 수 없음</p><ul><li>Node weight<ul><li>그래프에서 해당 logic block의 처리 시간을 나타내는 vertax에 weight 할당할 때의 문제<li>movable block의 가중치 : local / edge 서버 처리시간의 2배<ul><li>wishbone graph에서의 vertax 가중치 : 1개의 weight</ul></ul><li>Optimization goal<ul><li>wishbone에서의 최적화 목표 : 연산 budget / 네트워크 bandwidth 최소화<li>edgeprog에서의 최적화 목표 : latency에 초점<li>서로 원하는 최적화가 달라 공식이 적합하지 않음</ul></ul><li><p>edgeprog의 목적 : task 실행 latency 최소화 ( data flow 그래프에서 가장 긴 path의 길이를 최소화 )</p><ul><li><p>전체 경로를 source 정점 -&gt; sink 정점으로 표시 ( <em>p</em> )</p><li><p>len(<em>p</em>) : <em>p</em>의 길이</p><li><p>δ(<em>p</em>) : <em>p</em>에 있는 정점의 개수</p><li><p>P(G) : 그래프 G에 있는 모든 전체 경로 집합</p><li><p><strong>최적화 목표값</strong> : $min max_{p∈P(G)}len(p)$ ( p의 경로의 최댓값을 최소화 )</p><ul><li><p>추가로, len(p) == 모든 가능한 placement에 걸친 데이터 처리 / 전송 latency의 합이므로, $X_{b_is_i}$를 포함하여 공식화 가능 \(\underset{X}{\operatorname{\arg min}}\underset{p\in{P(G)}}{\operatorname{\max}} \sum_{i=1}^{\delta(p)}\sum_{s_i\in{S_i}} X_{b_is_i}{T_{b_is_i}^C} + \sum_{i=1}^{\delta(p)-1}\sum_{s_i\in{S_i}\\ s_{i'}\in{S_i'}} X_{b_is_i}X_{b_{i'}s_{i'}}T_{b_is_is_{i'}}^N\)</p><ul><li><p>$i$, $i’$ : 경로 p의 인접 정점 ( $i’ = i + 1$ )</p><li><p>$S_i$ : i번째 logic block을 설치할 수 있는 모든 공간의 집합</p><li><p>$T_{b_is_i}^C$ : i번째 블럭을 $s_i$에 설치 했을 때의 <strong>데이터 처리 시간</strong></p><li><p>$T_{b_is_is_{i’}}^N$ : i번째 블럭과 i+1번째 블럭 사이의 <strong>데이터 전송 시간</strong></p><ul><li><p>같은 위치 $s_i == s_{i’}$ 이라면 무시 가능 \(T_{b_is_is_{i'}}^N = \begin{cases} \lceil{\frac{q_{ii'}}{r_{ii'k}}}\rceil t_{ii'k} &amp; s_i\ne s_{i'}\\ 0 &amp; s_i = s_{i'} \end{cases}\)</p><ul><li>$q_{ii’}$ : edge에서 전송되어지는 data size<li>$r_{ii’k}$ : 프로토콜 <em>k</em>의 최대 패킷 payload를 나타내는 프로토콜 고유 metric<li>$t_{ii’k}$ : 각 패킷 전송 시간 ( 네트워크 profiler에 의해 측정 / 예측 )</ul></ul><li><p>위의 방정식 : Quadratic max/min problem ( NP-Hard 문제 )</p><ul><li><p>첨단 기술 : 휴리스틱 방식으로 해결</p><ul><li>최근 연구 : 그리디 bfs 알고리즘을 utilize<li>반면, local 최적에 덜 노출되어지는 solver를 사용하는 것을 선호</ul><li><p>방정식을 재공식화하여 integer programming problem으로 재구성 ( <code class="language-plaintext highlighter-rouge">lp_solve</code> 등의 standard solver로 해결 가능한 문제 )</p><ul><li><p>$\epsilon_{is_is_{i’}}=X_{b_is_i}\cdot X_{b_{i’}s_{i’}}$ : quadratic 목적함수 -&gt; 선형함수로 변환하여주는 보조변수</p><ul><li><p>이것이 존재하는 경우, 다음과 같은 제약조건 도입 \(\begin{aligned} \epsilon_{is_is_{i'}} &amp;\geq 0 \\ \epsilon_{is_is_{i'}} &amp;\leq X_{b_is_i} \\ \epsilon_{is_is_{i'}} &amp;\leq X_{b_{i'}s_{i'}}\\ \epsilon_{is_is_{i'}} + 1 &amp;\geq X_{b_is_i} + X_{b_{i'}s_{i'}} \\ \text{when } (\forall{i\in\delta(p)-1, s_i\in S_i, s_{i'}\in S_{i'}}) \end{aligned}\)</p><ul><li>4개의 제약조건은 모두 linear함</ul></ul><li><p>여전히 minmax 문제이므로, max 함수를 대표하는 보조변수 <em>z</em>를 선언</p><ul><li><p>z -&gt; 제약조건의 set으로 변경하여 표준 ILP 공식을 따르도록 함</p><li><p>재작성된 목적함수는 아래와 같음 \(\text{Objective: } \underset{X}{\operatorname{arg min}} z\)</p>\[\text{Subjective: } z\geq \sum_{i=1}^{\delta(p)}\sum_{s_i\in{S_i}} X_{b_is_i}{T_{b_is_i}^C} + \sum_{i=1}^{\delta(p)-1}\sum_{s_i\in{S_i}\\s_{i'}\in{S_i'}} \epsilon_{is_is_{i'}} T_{b_is_is_{i'}}^N, \forall{p}\in{G}\]<li><p>제약 추가 : 모든 logic block은 특정 device 하나에만 존재할 수 있다. \(\sum_{s_i\in{S_i}} X_{b_is_i}=1, \forall{i}\in{p}\in{G}\)</p></ul><li><p>So, 위의 모든 식들을 이용하여 계산한 <strong>Objective의 최적해가 input app의 최적 분할</strong></p></ul></ul></ul></ul></ul></ul></ul><h4 id="c-executable-generator">C. Executable Generator</h4><ul><li>2개의 step으로 구성<ul><li>최적의 파티션과 logic block으로부터 컴파일 가능한 code의 조각을 구성하는 단계<li>플랫폼에 맞게 실행 가능하도록 code를 컴파일하는 단계</ul><li>Contiki OS와 비슷하게, 감지 device뿐만 아니라 edge server에 대한 code도 생성할 수 있었음<ul><li>각각 플랫폼에 맞는 toolchain으로 컴파일<li>처리해야할 <strong>유일한 차이점</strong> : 다른 플랫폼에서 사용되어지는 다른 라이브러리 / 샘플링 API<li>초점 : <strong>어떻게 컴파일 가능한 code를 효율적으로 실행되도록 생성할 것인지?</strong></ul><li>logic block : app의 building block 역할을 할만큼 표현 가능하도록 설계되어짐<ul><li>최종 컴파일 가능한 code의 function으로 변환되어짐<li>issue : <u>생성된 code에서 function call을 구성하는 방법?</u><ul><li>직관적인 접근법 ( event-driven kernel / Contiki OS의 protothread 기술을 수용하기 위함 ) : 같은 placement에 할당된 모든 logic block을 protothread 안에 배열한 후, <strong>다음 block이 다른 device에 할당된 경우 데이터 주고받기</strong><ul><li>간단하지만, 성능 면에서 단점이 있음 ( 설계상 protothread가 매우 길어질 수 있음 -&gt; 시스템 성능 저하 )<li>하나의 block당 하나의 protothread를 만드는 것 또한 효율적이지 못함<ul><li>짧은 protothread : 많은 process 전환 overhead 초래 -&gt; 전체 makespan에 해악 초래</ul></ul><li>edgeprog의 접근법 : Contiki의 필수품인 code template / 수신 callback이 있는 send thread 기반 접근법<ul><li>기능적 protothread : 최적화된 유향 비순환그래프의 fragment로부터 생성<li>각 device의 fragment : 배치 변화 지점에서 끝나는 그래프 dfs를 활용하여 얻을 수 있음<li>이후 logic block의 함수를 호출하여 하나의 조각으로 protothread 조립<li>thread의 끝 : 데이터 전송을 위해 send thread에게 event 발생시킴<ul><li>다른 thread에게 yield</ul><li>time profiling : 그래프 fragment는 system health를 위해 몇가지 시간소모적인 task를 포함하고 있다면, 더욱 세분화될 수 있음</ul></ul></ul></ul><h2 id="evaluation">Evaluation</h2><h4 id="a-experiment-setup">A. Experiment Setup</h4><ul><li>5개의 macro-benchmark 사용할 것 ( 2개의 센싱 app / 3개의 real-world app )<ul><li>Sense : outlier detection / data 압축 등을 하는 일반적인 센싱 app<li>MNSVG : 온도 / 습도를 예측하기 위해 MNSVG 모델을 사용하는 날씨 예측 app<li>EEG : wishbone으로부터 취해진 seizure 감지를 위한 EEG signal 사용<ul><li>각 channel : 7차 wevelet 분해로 EEG 신호를 처리 ( 10개의 병렬채널 )</ul><li>SHOW : device의 궤적을 IMU 정보, 랜덤 forest 알고리즘 등으로 감지 / 분류<li>Voice : 신호처리 / 분류 알고리즘 등을 이용하여 speaker 수를 셈</ul></ul><h5 id="baseline-definition">Baseline Definition</h5><ul><li>edgeprog와 비교할 첨단연구를 소개<ul><li>RT-IFFFF : 서버가 모든 연산 수행<ul><li>센서 : 값을 전달 / 실행만 함</ul><li>Wishbone(0.5, 0.5) : CPU / network 자원을 반반 쓰는 파티셔닝 시스템<li>Wishbone(opt.) : CPU / network workload를 최소로 하는 상태의 파라미터를 사용하는 wishbone</ul></ul><h4 id="b-latency-reduction">B. Latency reduction</h4><ul><li>평균적으로 20.96% 감소 / 최대 99.05% 감소<li>2가지 주요 관찰결과<ul><li>벤치마크에 따라 속도 상승률이 상당히 다름<ul><li>변화 원인 : 각 벤치마크의 계산복잡성 / 네트워크 요구량의 차이</ul><li>Zigbee 네트워크에서의 edgeprog 성능 &gt; WIFI 네트워크에서의 edgeprog 성능<ul><li>가능한 모든 절단 지점에서 각 벤치마크를 철저히 실행함으로써 증명<li>네트워크 속도 증가 = 데이터 전송시간 감소 / 데이터 처리에 시간을 지배적으로 사용<ul><li>최적화 알고리즘 : 초기에 작업을 offload하는 것을 선호<li>따라서, WIFI에서의 전환점이 Zigbee보다 왼쪽에 존재함<ul><li>최적화 공간의 감소 의미 ( 기준선과 비슷한 성능 초래 )</ul></ul></ul></ul></ul><h4 id="c-overhead">C. Overhead</h4><h5 id="disemination-overhead">Disemination Overhead</h5><ul><li>알고리즘의 복잡성이 클수록 binary 크기가 증가<li>연산이 많아도 binary가 작은 경우가 있음<ul><li>각 절차가 동일한 절차를 공유하기 때문 ( 주로 하나의 알고리즘 사용 )</ul></ul><h5 id="run-time-efficiency">Run-time efficiency</h5><ul><li>동적 링크 / 로딩 기술 runtime 효율성 측정 ( 가상머신 / 스크립팅 언어 )<li>결과<ul><li>VM을 사용하였을 때 실행시간은 매우 김<li>edgeprog 언어를 사용하지 않았을 때보다 더 많은 실행시간 초래</ul></ul><h4 id="d-programming-language">D. Programming Language</h4><ul><li>Contiki 스타일 / Edgeprog 스타일 비교<li>결과<ul><li>edgeprog : 평균 79.41%의 line 감소 나타냄<ul><li>복잡한 장치간 상호작용 작성 완화 / 기타 문법 필수사항 작성 완화<li>가상센서 / IFTTT 추상화 방법 또한 기여</ul><li>edgeprog : 더 많은 device가 포함된 app 개발의 복잡성 감소<ul><li>모든 장치에 대한 개별코딩이 필요하지 않기 때문</ul></ul></ul><h4 id="e-profiling-accuracy">E. Profiling Accuracy</h4><ul><li>TelosB가 더 높은 정확도 달성<li>라즈베리파이가 정확도가 조금 불안정한 모습 ( CPU의 주파수 변동 / 라즈베리 파이의 배경 처리 기인 )</ul><h2 id="related-work">Related Work</h2><h2 id="conclusion">Conclusion</h2><ul><li>프로그램을 자동으로 분할 / 생성 / 보급 / 로드하는 EdgeProg 제안<ul><li>개발자가 상세한 구현으로부터 완화될 수 있는 edge 중심 프로그래밍 시스템</ul><li>개발자 / 비전문가에게 사용하기 쉽고 표현력이 좋은 프로그래밍 언어 제공<li>코드 파티셔너 : ILP 공식을 통해 응용프로그램의 각 부분에 대해 가장 효율적인 배치를 찾음<li>핵심 : 각 device의 계산 능력을 최대한 활용 / latency 감소 달성</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/imes/'>IMES</a>, <a href='/categories/paper/'>paper</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/imes/" class="post-tag no-text-decoration" >IMES</a> <a href="/tags/paper/" class="post-tag no-text-decoration" >paper</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=EdgeProg: Edge-centric Programming for IoT Applications - Joe2357&url=https://joe2357.github.io/posts/EdgeProg/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=EdgeProg: Edge-centric Programming for IoT Applications - Joe2357&u=https://joe2357.github.io/posts/EdgeProg/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=EdgeProg: Edge-centric Programming for IoT Applications - Joe2357&url=https://joe2357.github.io/posts/EdgeProg/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/SCPC-2021-Round-1/">SCPC 2021 1라운드 후기</a><li><a href="/posts/SCPC-2020-Round-1/">SCPC 2020 1라운드 후기</a><li><a href="/posts/728/">Codeforces Round #728 (Div. 2) 후기</a><li><a href="/posts/727/">Codeforces Round #727 (Div. 2) 후기</a><li><a href="/posts/726/">Codeforces Round #726 (Div. 2) 후기</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ps/">PS</a> <a class="post-tag" href="/tags/review/">Review</a> <a class="post-tag" href="/tags/codeforces/">Codeforces</a> <a class="post-tag" href="/tags/imes/">IMES</a> <a class="post-tag" href="/tags/paper/">paper</a> <a class="post-tag" href="/tags/scpc/">SCPC</a> <a class="post-tag" href="/tags/ds/">DS</a> <a class="post-tag" href="/tags/storage/">Storage</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/WebRTC/"><div class="card-body"> <span class="timeago small" > May 26 <i class="unloaded">2021-05-26T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Audio and Video Mixing Method to Enhance WebRTC</h3><div class="text-muted small"><p> 2021 / 7 / 21 IMES 세미나 Abstract WebRTC : 웹브라우저에 JavaScript API를 호출함으로써 P2P 라이브 스트리밍 제공 소수의 peer로 제한되는 프로토콜 ( 다중 peer들의 real-time 스트림을 mix하기 힘듬 / mix된 스트림을 많은 수의 audience에게 분배할 수...</p></div></div></a></div><div class="card"> <a href="/posts/PBE-CC/"><div class="card-body"> <span class="timeago small" > Nov 26, 2020 <i class="unloaded">2020-11-26T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>PBE-CC: Congestion Control via Endpoint-Centric, Physical-Layer Bandwidth Measurement</h3><div class="text-muted small"><p> 2021 / 1 / 20 IMES 세미나 Abstract cellular network는 복잡해지고 과밀되어짐 delay, jitter 등의 문제 발생 PBE-CC : sender가 정확하고 급격하게 반응할 수 있도록 하는 최신 5G radio 혁신 기반 congestion control 알고리즘 ...</p></div></div></a></div><div class="card"> <a href="/posts/MPBond/"><div class="card-body"> <span class="timeago small" > Jan 21 <i class="unloaded">2021-01-21T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MPBond: Efficient Network-level Collaboration Among Personal Mobile Devices</h3><div class="text-muted small"><p> 2021 / 2 / 17 IMES 세미나 Abstract MPBond : 여러 개인 mobile device가 공동으로 internet에서 content를 가져올 수 있도록 하는 효율적인 system 스마트워치 : data downloading을 통해 페어링된 스마트폰 지원 MPTCP ( Multipath...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Edge-Assisted-Real-time-Object-Detection-for-MAR/" class="btn btn-outline-primary" prompt="Older"><p>Edge Assisted Real-time Object Detection for Mobile Augmented Reality</p></a> <a href="/posts/710/" class="btn btn-outline-primary" prompt="Newer"><p>Codeforces Round #710 (Div. 3) 후기</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/username">Joe2357</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/ps/">PS</a> <a class="post-tag" href="/tags/review/">Review</a> <a class="post-tag" href="/tags/codeforces/">Codeforces</a> <a class="post-tag" href="/tags/imes/">IMES</a> <a class="post-tag" href="/tags/paper/">paper</a> <a class="post-tag" href="/tags/scpc/">SCPC</a> <a class="post-tag" href="/tags/ds/">DS</a> <a class="post-tag" href="/tags/storage/">Storage</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://joe2357.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
