<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Audio and Video Mixing Method to Enhance WebRTC" /><meta name="author" content="Joe2357" /><meta property="og:locale" content="en_US" /><meta name="description" content="2021 / 7 / 21 IMES 세미나" /><meta property="og:description" content="2021 / 7 / 21 IMES 세미나" /><link rel="canonical" href="https://joe2357.github.io/posts/WebRTC/" /><meta property="og:url" content="https://joe2357.github.io/posts/WebRTC/" /><meta property="og:site_name" content="Joe2357" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-05-26T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Audio and Video Mixing Method to Enhance WebRTC" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Joe2357" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Joe2357"},"headline":"Audio and Video Mixing Method to Enhance WebRTC","dateModified":"2021-05-26T00:00:00+09:00","datePublished":"2021-05-26T00:00:00+09:00","description":"2021 / 7 / 21 IMES 세미나","url":"https://joe2357.github.io/posts/WebRTC/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://joe2357.github.io/posts/WebRTC/"},"@context":"https://schema.org"}</script><title>Audio and Video Mixing Method to Enhance WebRTC | Joe2357</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "AMS" } }, tex2jax: { inlineMath: [ ['$', '$'] ], displayMath: [ ['$$', '$$'] ], processEscapes: true, } }); MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) { alert("Math Processing Error: "+message[1]); }); MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) { alert("Math Processing Error: "+message[1]); }); </script> <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Joe2357</a></div><div class="site-subtitle font-italic">공부하는 블로그</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/Joe2357" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['deviljoe996','gachon.ac.kr'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Audio and Video Mixing Method to Enhance WebRTC</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Audio and Video Mixing Method to Enhance WebRTC</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, May 26, 2021, 12:00 AM +0900" > May 26 <i class="unloaded">2021-05-26T00:00:00+09:00</i> </span> by <span class="author"> Joe2357 </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="9192 words">51 min</span></div></div><div class="post-content"><blockquote><p>2021 / 7 / 21 IMES 세미나</p></blockquote><h2 id="abstract">Abstract</h2><ul><li>WebRTC : 웹브라우저에 JavaScript API를 호출함으로써 <u>P2P 라이브 스트리밍</u> 제공<ul><li>소수의 peer로 제한되는 프로토콜 ( 다중 peer들의 real-time 스트림을 mix하기 힘듬 / mix된 스트림을 많은 수의 audience에게 분배할 수 없음 )<li>예시 : [ 회의 참여자의 오디오/비디오 스트림을 1만 이상의 audience에게 real-time mixed stream으로 방송, 동기 컨텐츠(로고, 음악) 혼합 ] -&gt; WebRTC가 현재는 <strong>방법을 제공하지 않음</strong></ul><li>이 논문에서 위의 case를 최소한의 latency로 줄이며 동기화 mixed real-time 오디오/비디오 스트림을 제공하는 방법을 제시<ul><li>온라인 live 회의 구현 가능함 ( 다중 peer의 화상회의 스트림을 mix / 그것을 많은 수의 청중들에게 스트림 제공 )</ul></ul><h3 id="introduction">Introduction</h3><ul><li>W3C, IETF : WebRTC 고안 ( 웹브라우저에서 real-time으로 오디오/비디오 커뮤니케이션 실현 )<ul><li>standard / 프로토콜 / JS API의 collection - 브라우저를 통해 P2P 오디오/비디오/data 공유 가능<li>브라우저에 내장 - 별도 플러그인 필요 없음</ul><li>현대 인기 웹 app : 웹브라우저와 호환<ul><li>standard JS API를 통해 필요한 모든 resource 관리 가능 ( 마이크/카메라 등 )</ul><li>WebRTC 구조 : P2P 네트워크 연결<ul><li>RTP/SRTP : 미디어 스트리밍 프로토콜<li>Interactive Connection Establishment ( ICE ) : 연결 수립 프레임워크<ul><li>session traversal utility 지원 ( NAT, STUN, TURN )<li>TURN은 P2P 연결이 불가능할 경우 STUN 대신 사용됨</ul></ul><li>UDP 프로토콜 위에서 동작 -&gt; <strong>빠르고 안정적인 스트리밍 미디어 소통 프레임워크</strong><li>문제점 : <u>peer가 많아질수록 효율적이지 못함</u><ul><li>peer가 $N$명일 경우 연결이 $N-1$번 필요 ( 각 peer들과 전송/전달 스트리밍 연결을 가져야함 )<li>Ex) 720p 비디오 bitrate = 1.5Mbps, $N=100$이라고 가정<ul><li>한 peer가 1Gbps 이상의 downlink/uplink를 유지해야함 -&gt; 모든 사람이 회의에 참여하는 것은 힘들 것<li>소수의 인원으로 제한됨 ( 나머지 대규모의 인원은 말하지 않는 청중이 될 것 )</ul></ul><li>스트림 전송은 WebRTC 프로토콜을 통해 이루어져야함 ( 안정성 / 낮은 latency )<ul><li>순수 P2P 매커니즘 : 다수의 청중에게 재방송할 수 없음 ( bandwidth 제한 )<li>이 논문에서는 “<u>오디오/비디오 스트림을 mix하여 재방송하는 효율적인 방법에 대한 논의</u>“를 담음<ul><li>두 스트림의 동기화 + 실시간성을 보장하는 방법 포함</ul></ul></ul><h2 id="overview-of-our-study">Overview of Our Study</h2><h3 id="a-architecture">A. Architecture</h3><ul><li>기존 WebRTC 구조에서 input -&gt; mixing process로의 오디오/비디오 패킷을 얻기 위해, 구조를 조정함 ( WebRTC gateway에 <strong>quasi-peer</strong> 추가 )<ul><li>quasi-peer : 다른 피어들과 비슷하게 동작하여 연결되지만, 자신의 미디어 스트림을 생성하지 않음 ( 연결하여 다른 피어의 data는 수집 )<li>모든 정보들을 mix하여 ICE 등의 방법으로 audience들에게 output 분배</ul></ul><h3 id="b-the-process-inside-the-quasi-peer">B. The Process inside the Quasi-Peer</h3><ul><li>멀티채널 WebRTC 스트림 믹싱 프로세스 : 오디오/비디오 data packet을 따로 병렬로 decode / buffer한 후 mix하여 syncronization / forwarding<ul><li>global timeline 있음 ( 멀티미디어 시스템 동기화에서 중요한 요소 )</ul><li>구성요소<ul><li>A. 멀티채널 WebRTC data packet을 받는 모듈<ul><li>멀티스레드 모듈 ( 다른 peer로부터 스트림 데이터를 받음 )</ul><li>B. 오디오/비디오 data packet 전처리 모듈<ul><li>WebRTC 사양에 의해 두 패킷은 다른 채널들에 의해 identifier를 단 헤더로 정보도 전달됨<li><strong>두 data pakcet은 별도로 전처리되어야 함</strong> ( 수신 후 전처리되어야하기 때문 )<ul><li>전처리 과정에서 WebRTC 프로토콜에서 정의된 오디오/비디오 data 특성에 따라 data를 처리해야함<li>오디오는 frequency가 높고 패킷이 작음 / 비디오는 frequency가 낮고 패킷이 큼 -&gt; 비디오는 여러 패킷으로 분할되어질 것</ul><li>패킷 손실 판단 / 패킷 재배열 등의 문제 있음 ( WebRTC가 UDP에서 동작하기 때문 )</ul><li>C. 오디오/비디오 디코딩 / 버퍼링 모듈<ul><li>디코딩 프로세스 담당<li>자신의 인코딩 사양에 따라 오디오/비디오를 디코딩<li>다음 모듈을 위해 buffer에 저장</ul><li>D. 오디오/비디오 믹싱 모듈<ul><li>멀티채널 오디오/비디오를 하나의 시청용 오디오/비디오로 mix하는 역할<li>통합된 타임스태프 내에서 mix될 디코딩될 data의 상대적 타임스태프를 계산<ul><li>하드웨어 방식으로 인코딩 ( 효율성 목적 )</ul></ul><li>E. 동기화 / forward 모듈<ul><li>output을 내기 위한 마지막 모듈<li>동기화를 위해 D1과 D2에서 계산한 시간을 다시 계산<li>mix된 매채 : ICE agent에 의해 유지되는 WebRTC P2P연결을 통해 수신 터미널에 relay -&gt; 배포 준비 완료</ul><li>위의 단계 : WebRTC에 의해 정의된 모듈이 아님 / 또한 고립된 모듈도 아님<ul><li>quasi-peer에 포장되어진 단계들임 ( WebRTC가 그냥 peer라고 믿게 만듬 ) // 사실 다른 peer와의 대화 없이 오디오/비디오 정보를 수집<li>quasi-peer : WebRTC가 정의한 peer가 아닌 유사 peer</ul></ul></ul><h2 id="implementation-in-quasi-peer">Implementation in Quasi-Peer</h2><ul><li>A, C단계는 이미 연구가 많이 진행되어 특별한 노력 없이 사용 가능<ul><li>B, D, E 단계에서는 문제를 해결해야함</ul><li>다른 위치에서 peer들이 회의에 참여하여 stream 생성중<ul><li>각각 2개의 스트림으로 분리 ( 오디오 / 비디오 )<li>각 peer는 회의에 참여하는 시간이 모두 다름<ul><li>오디오 / 비디오를 전송할 때, 전송되는 패킷에 local timestamp 정보가 계산되어짐</ul></ul><li>mixing이 시작되는 시간 또한 정해져있지 않음 ( 시작할 때 각각의 peer에게서 수신받은 frame이 모두 다를 것 )<ul><li>quasi-peer에 각 peer들에 대한 버퍼 정렬 queue가 있음<li>현재 시간까지 <strong>완벽하게 들어온</strong> 프레임들을 수신해서 가지고 있을 것<li>quasi-peer가 시작된 이후에는 <u>mixed 오디오/비디오 stream을 생성해야함</u> ( 정해진 오디오 / 비디오 샘플링 frequency )</ul><li>오디오 / 비디오 혼합 스트림 제작 과정 ( 주체 : quasi-peer )<ul><li>비디오 이미지 우선순위 원리 -&gt; quasi-peer가 가장 마지막에 받은 이미지를 이용하여 mix할 것<li>동시에 output timestamp보다 작거나 같은 최신 오디오를 사용하여 혼합<li>mix 이후 참여하는 스트림의 경우에도 이와 같은 방법으로 혼합<li>각각의 local timestamp는 모두 다름 -&gt; <strong>기준을 하나의 peer로 잡으면 안되는 독립적인 timestamp</strong><ul><li>global timeline의 필요성 : quasi-peer의 local timestamp로 이해할 수 있음</ul></ul><li>각 peer가 스트림을 전송하는 시간이 모두 다름<ul><li>quasi-peer가 한 작업 : 각 peer들의 시간 차이를 최소화함<li>but 궁극적인 목적 : <u>멀티미디어 스트림 data와 다른 source로부터의 상관 관계를 output mixing 멀티미디어 스트림에 유지하는 것</u><ul><li>이것에는 audience들의 멀티미디어 컨텐츠도 동기화될 것</ul><li>본 논문에서 제시하는 모델 : 시간적 동기화 모델<ul><li><p>수학적 증명 ( 사용 기호 )</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">기호<th style="text-align: center">설명<tbody><tr><td style="text-align: center">$P = \left\{ p^1,…,p^N\right\} $<td style="text-align: center">$N$개의 peer<tr><td style="text-align: center">$R^x = \left\{ v^x, a^x\right\} $<td style="text-align: center">peer $p^x$에서 생성된 멀티미디어 데이터셋 ( 비디오 / 오디오 )<tr><td style="text-align: center">$S^x = \left\{ s_v^x, s_a^x\right\}$<td style="text-align: center">peer $p^x$으로부터 전송된 스트림 ( 비디오 / 오디오 )<tr><td style="text-align: center">$s_v^x=\left\{ f_v^x(1),…,\right\}$<td style="text-align: center">스트림에 대한 각 프레임 집합<tr><td style="text-align: center">$s_{a\to v}^x=\left\{f_{a\to v}^x(1),…, \right\}$<td style="text-align: center">peer $p^x$의 각 프레임에 대해 대응하는 비디오 프레임 집합<tr><td style="text-align: center">$O$<td style="text-align: center">quasi-peer<tr><td style="text-align: center">$s_v^O=\left\{ f_v^O(1),…,\right\}$<td style="text-align: center">quasi-peer에 의해 혼합된 output 프레임<tr><td style="text-align: center">$ts(f)$<td style="text-align: center">프레임 f의 timestamp</table></div><li><p>오디오 / 비디오 프레임이 timeline에 따라 시간에서 상관관계를 가지고 있음</p><li><p>quasi-peer의 이상적인 목적</p><ul><li><p>실제 세계에서 동시에 발생하는 <u>모든 peer들의 스트림 혼합 + 동기화</u></p><li><p>각 peer의 컴퓨팅 파워 / 네트워크 조건 / clock 정확도 차이 등에 의해 P2P 분산 모드에서는 <strong>허용 가능한 수준에서만 stream을 동기화할 수 있음</strong> ( interstream 동기화에 외부 참조 stream이 없음 )</p><li><p>이상적이라면 mixed frame을 만들 때 <strong>지금까지 온전히 받은 가장 최신의 frame을 사용</strong>할텐데, 현실적으로 <strong>불가능함</strong></p><ul><li>그러나 차이가 $T = [-100ms, 25ms]$라면 사람이 보기에 수용 가능할 것<li>이에 의해 $f_v^O(k), f_a^O(m)$을 재정의함 ( output video / audio frame )</ul><p>$\forall k, f_v^O(k) \in s_v^O, \exists Y \subseteq \left\{ 1…N \right\} : f_v^O(k)=\sum_{x \in Y} f_v^x (?) \tag{1}$<br /> $\forall m, f_a^O(m) \in s_a^O, \exists Y \subseteq \left\{ 1…N \right\} : f_a^O(m)=\sum_{x \in Y} f_a^x (??) \tag{2}$</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">기호<th style="text-align: center">설명<tbody><tr><td style="text-align: center">$k$, $m$<td style="text-align: center">프레임 번호<tr><td style="text-align: center">$Y$<td style="text-align: center">$\left\{ 1 … N\right\}$의 subset<tr><td style="text-align: center">$f_v^O(k)$<td style="text-align: center">$Y$의 peer set으로부터 제공되는 프레임의 혼합 프레임<tr><td style="text-align: center">$f_v^x(?)$<td style="text-align: center">peer $p^x$로부터 제공되는 프레임</table></div><li><p>WebRTC 사양에 따라 $s_v^x, s_a^x$는 local timeline을 기반으로 함 ( data 생성 / 전송에서의 동기화 보장 목적 )</p><ul><li><p>위 2개의 공식을 조합하여, quasi-peer의 혼합 출력 스트림의 오디오/비디오 동기화 skew가 <u>각 peer의 이미지 / 오디오 사이의 offset의 축적 / 합으로 구성됨</u>을 정의할 수 있음</p><li><p>새로 정의</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">기호<th style="text-align: center">설명<tbody><tr><td style="text-align: center">$\sum_{x \in Y} ts(f_v^x (?))$<td style="text-align: center">혼합 스트림에서 $k$번째 오디오 프레임에 대응하는 비디오 프레임의 timestamp 합<tr><td style="text-align: center">$\sum_{x \in Y} ts(f_{a \to v}^x (??))$<td style="text-align: center">각각의 원래 스트림에서 혼합 스트림에서 $k$번째 오디오 프레임에 대응하는 비디오 프레임의 timestamp 합<tr><td style="text-align: center">$D(f_a^O(k), f_{a \to v}^O(k))$<td style="text-align: center">위 2개의 변수의 skew value</table></div><p>$D(f_a^O(k), f_{a \to v}^O(k))$<br /> $= |\sum_{x \in Y}ts(f^x_v(?)) - \sum_{x \in Y} ts(f_{a \to v}^x(??)) |$<br /> $= \sum_{x \in Y} |ts(f^x_v(?)) - ts(f_{a \to v}^x(??)) | \tag{3}$</p><li><p>위 식을 이용하여, 전체 동기화 프로세스 -&gt; <strong>time offset을 최소화하는 최적화 문제</strong>로 변환 가능</p><p>$\min \left(\sum_{k}D(f_a^O(k), f_{a \to v}^O(k)) \right)$ <br /> $= \sum_{k} \min \left( \sum_{x \in Y}|ts(f^x_v(?)) - ts(f_{a \to v}^x(??))| \right) \tag{4}$</p></ul></ul></ul></ul></ul><h3 id="a-multichannel-webrtc-data-packets-received-in-module-a">A. Multichannel WebRTC Data Packets Received in Module A</h3><ul><li>WebRTC : 오디오 / 비디오 채널이 여러개 존재 -&gt; 처리를 위한 여러개의 thread 필요<ul><li>각 thread : 오디오 / 비디오 채널 1개의 data 수신 역할</ul></ul><h3 id="b-audio--video--data-packet-preprocess-module-in-b1--b2">B. Audio ( Video ) Data Packet Preprocess Module in B1 &amp; B2</h3><ul><li>WebRTC 사양에 의해 스트리밍 data를 패킷화할 때 표준 RTP 포맷 사용<ul><li>RTP 패킷 header에는 <code class="language-plaintext highlighter-rouge">seq_number</code>와 <code class="language-plaintext highlighter-rouge">timestamp</code>가 중요<ul><li><code class="language-plaintext highlighter-rouge">seq_number</code> : 패킷의 serial number<li><code class="language-plaintext highlighter-rouge">timestamp</code> : 패킷이 물리적으로 만들어진 때의 timestamp ( 주로 상대적인 시간 )</ul><li>WebRTC는 UDP 위에서 동작한다 -&gt; 패킷 정렬 / 손실 판단 / 손실 재배열 등을 수행해야함 ( 다음 단계에서 성공적인 decoding을 위함 )</ul><li><p>패킷을 정렬할 때 순서를 결정하기 위해 timestamp를 비교해야하는데, 이것은 peer stream의 local timeline에서 비교되어야함</p><ul><li><p>RTP 패킷 표준에서 local timeline의 시작점의 상대시간은 0이 될 수 없음</p><ul><li>RTP 패킷의 timestamp 시간을 실시간으로 변환해야함 ( 공식 5 사용 )</ul><li><p>실시간을 얻기 위해서는 전처리 시작 단계에서 패킷 정렬 / 삽입 / 폐기 / 무행동 등을 판단해야함 -&gt; <u>패킷 실제 생성 시간</u> <code class="language-plaintext highlighter-rouge">real_ts</code>를 알아야 함</p><ul><li><p><code class="language-plaintext highlighter-rouge">start_ts</code> : 첫 패킷 스트림 생성 실제 시간</p><li><p><code class="language-plaintext highlighter-rouge">timestamp</code> : 시작으로부터 경과된 상대시간</p><p>$\text{real_ts} = \text{start_ts} + \frac{\text{timestamp}}{\text{timebase}} \tag{5}$</p></ul><li><p>오디오 전처리는 비교적 간단</p><ul><li>WebRTC에서의 오디오 샘플링 주파수 : 48000<ul><li>WebRTC 패킷은 OPUS 형식에 따라 960개의 인코딩된 data 샘플 운반<li>그래서 data 패킷의 길이 = $960/48000=20\text{ms}$</ul><li>인간이 20ms의 data 손실을 감지할 수는 없으므로, 패킷 손실 및 재전송 등의 처리를 건너뛸 수 있음<ul><li><code class="language-plaintext highlighter-rouge">timestamp</code>를 이용한 패킷 분류 / 정렬 등을 수행</ul><li>각 peer는 오디오 버퍼 queue가 설정됨<ul><li>큐가 데이터를 추가할 때마다 패킷의 timestamp와 현재 수신된 최신 데이터 패킷 사이의 gap이 threshold를 초과하는지 여부를 판단함<ul><li>실험상 0.5s 이하로 설정하는 것이 좋음</ul><li>버퍼 큐 존재 이휴 : UDP 패킷의 out-of-order를 방지하기 위함</ul></ul><li><p>비디오 전처리 단계는 좀 많이 복잡함</p><ul><li><p>WebRTC에 의해 지정된 단일 RTP 패킷이 연속적인 이동 프레임 data를 모두 담을 수 없으므로, 인코딩된 하나의 frame data는 여러개의 패킷으로 분할되어짐</p><ul><li>분할된 패킷은 동일한 timestamp, 연속적인 번호의 seq_number를 가지게 됨</ul><li><p>인코딩된 비디오 프레임은 여러개의 연속 RTP 패킷으로 전송됨</p><ul><li>만약 $p^1$의 마지막 전송된 RTP 패킷의 seq_number = 12이고 프레임에서 3개의 RTP 패킷이 필요한 경우, 필요한 RTP 패킷의 seq_number = 13, 14, 15일 것</ul><li><p>B2 ( 비디오 데이터 패킷 전처리 모듈 ) 에서의 수도코드</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>Procedure 1
    Input : The pkt_cur Receives the WebRTC Packet to Be Preprocessed,
    and the QVs Is the Packet Buffer Queue in Desending Order of seq_number and timestamps
</pre></table></code></div></div><pre><code class="language-pseudocode">1| Generic WebRTC data packets preprocess()
2|  Parse the pkt_cur header and the data area to obtain video extension information;
3|  Determine whether it is an invalid data packet comprehensively, iscard invalid data packets according the information in line 2;
4|  Copy pkt_cur and insert the copied packets into the queue QV in descending order by the packet's seq_number;
5|  for (pkt_q in QV)
6|    Discard all the current packets if the difference between timestamp of pkt_q and the timestamp of pkt_q and the timestamp of pkt_cur bigger than θ;
7|    Go backwards to judge whether the seq_number of the packet with the timestamp of pkt_q is continuous, and the packet loss management is started if it is not continuous;
8|    If all the WebRTC packets of a complete video frame are received, parse the video encoding header information of the WebRTC packet payload data to obtain the height and width information of the video image and determine whether there is any change;
</code></pre><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    Output : timestamp of the first complete video frame in QV,
    buffer queue QV, current video image height and width information
</pre></table></code></div></div><ul><li>1~6번 줄 : buffer queue에서 충분히 오래된 늦은 video frame data의 backlog를 탐지할 때 트리거됨<ul><li>video buffer queue는 각 peer에 대해 설정됨 / 수신된 video frame은 frame의 timestamp의 내림차순으로 넣어짐<li>큐에 data를 넣을 때마다, 큐의 패킷의 timestamp와 수신된 패킷 사이의 시간 차이가 threshold를 넘는지 판단<ul><li>임계값은 경험에 의해 설정하거나 이전 오디오 threshold값과 같을 수 있음</ul></ul><li>7번 줄 : 불연속적인 패킷이 있는지의 여부 결정 ( 패킷 손실이 제어 가능한 정도인지 결정하기 위함 )<ul><li>제어 가능한 정도라면 RTCP 제어 프로토콜을 이용하여 sender에게 재전송 통보<li>불가능하다면 frame loss management가 trigger<ul><li>손실된 프레임의 누적 data 계산<li>RTCP을 이용하여 피드백 전송<li>stream data 전송 종료</ul><li>buffer overflow 방지를 위해 너무 오래된 백업 data는 폐기</ul></ul><li><p>요약</p><ul><li>PCM 형식으로 복호화하기 위해 Procedure 1에서 설명한 <strong>Audio data packet Preprocessing</strong> 수행<li>Video WebRTC packet의 경우 Procedure 1에서 표시된 전처리 후 <u>완전한 최신 video frame으로 복호화</u></ul></ul></ul></ul><h3 id="c-audio--video--decoding-and-buffering-module-in-c1--c2">C. Audio ( Video ) Decoding and Buffering Module in C1 &amp; C2</h3><ul><li>권장 오디오 인코딩 형식 : OPUS // 권장 비디오 인코딩 형식 : H.264, VP8<ul><li>다른 표준 알고리즘 또한 사용 가능</ul><li>표준 디코딩 알고리즘을 사용하기 때문에 구현이 비교적 간단할 것</ul><h3 id="d-audio--video--mixing-with-a-universal-timestamp-module-in-d1--d2">D. Audio ( Video ) Mixing with a Universal Timestamp Module in D1 &amp; D2</h3><ul><li><p>오디오 mixing : 어떤 constant 파라미터에 따라 메모리 크기를 계산해야함</p><ul><li>WebRTC 오디오 data packet은 960개의 샘플 전송 // PCM으로 디코딩한 샘플은 2개의 data channel 포함<li>하나의 채널의 data는 16-bit 정수 data로 간주할 수 있음<li>=&gt; $2\times 2\times 960=3840$bytes의 메모리 저장공간이 필요<li>오디오 샘플의 left/right 채널 data : left/right interleaved mode에 저장됨</ul><li><p>가정</p><ul><li>left/right interleaved mode에 저장된 두 오디오 샘플 $L_1R_1$, $L_2R_2$ : 하나의 오디오 샘플로 mix될 것<li>혼합 오디오 PCM buffer : <code class="language-plaintext highlighter-rouge">buff_out</code><li>β : 혼합된 소리의 popping sound를 억제하기 위한, 실제 필요에 따라 조정할 수 있는 떨림조정계수</ul><li><p>공식 도출 가능 ( 실시간 멀티채널 오디오 mixing할 때 )</p><ul><li><p>수신된 오디로를 PCM data로 직접 변환해야함</p><li><p>$Lout$, $Rout$ 위치에 해당하는 오디오의 mixing value를 순차적으로 계산해야함</p><center> $Lout=(L_1+L_2)*β$ <br /> $Rout=(R_1+R_2)*β$ <br /> $β=[0.5, 0.8] \tag{6}$ </center></ul><li><p>비디오 mixing : peer들의 비디오를 audience에게 뿌릴 하나의 비디오로 꿰메야함</p><ul><li>모든 비디오들의 pixel 해상도는 다를 수 있음<li>대신 종횡비는 동일해야하므로, 혼합 비디오 프레임 layout은 대중적인 2가지 경우를 사용함<ul><li>Multiple squares layout<li>Overlapped layout</ul></ul><li><p>video codec의 부담을 줄이기 위해 YUV data processing에서 video frame stitching이 수행됨</p><ul><li>YUV : 2가지 형식으로 나누어짐 색상 코딩 방법 ( packed / planer format )<ul><li>packed : Y, U, V가 배열로써 저장됨 ( RGB와 비슷한 방식 )<li>planer : Y, U, V를 서로 다른 행렬에 저장</ul><li>이후 단계를 쉽게 하기 위해 planer 방식 채용</ul><li><p>비디오 mixing 과정</p><ul><li><p>가정</p><ul><li>출력 비디오 프레임의 예상 높이 $H$ * 폭 $W$<li>입력 비디오 프레임의 높이 $H_{in}$, 폭 $W_{in}$<li>출력 비디오 프레임의 높이 $H_{\text{in_scale}}$, 폭 $W_{\text{in_scale}}$<li>출력 비디오 프레임의 왼쪽 상단 모서리의 좌표 $(x, y)$<li>대상 비디오 프레임에서 U와 V의 시작 위치 $U_{pos}$, $V_{pos}$</ul><li><p>알고리즘 ( 멀티채널 비디오를 mixing하는 방법 )</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Procedure 2
    Input : The height and width of the output video frame are H * W,
    the height and width of the input video frame are H_in * W_in,
    the expected scale is H_in_scale * W_in_scale,
    and the upper left corner position is (x, y)
</pre></table></code></div></div><pre><code class="language-pseudocode"> 1| Multichannel video mix()
 2|   Calculate the scale ratio and scale the input frame to the target size;
 3|   for (i in H_in_scale)
 4|     Calculate the target copy start position Y_pos of the line where the Y component of the i-th line of the input frame is scaled in the target output frame;
 5|     Copy the i-th ine of the scaled input frame Y cmponent to the target space starting with Y_pos;
 6|     for (i in H_in_scale)
 7|       Calculate the U_pos of the U component of the i-th line scaled by the input frame according to the halved height-width information in the target output frame;
 8|       Copy the i-th line of the scaled U frame of the input umage to the target space starting with U_pos;
 9|       Calculate the V_pos of the V component of the i-th line scaled by the input frame according to the halved height-width information in the target output frame;
10|       Copy the i-th line of the scaled V frame of the input umage to the target space starting with V_pos;
</code></pre><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>    Output : the frame after mixing
</pre></table></code></div></div></ul><li><p>요약</p><ul><li>D1, D2 : 각각의 혼합 thread를 가지고 있음<ul><li>오디오 mixing thread : 최신 혼합 오디오 데이터를 인코딩, 패킷화<li>비디오 mixing thread : 출력 캔버스에 최신 프레임을 인코딩</ul></ul></ul><h3 id="e-synchronization-and-forwarding-module-e">E. Synchronization and Forwarding Module E</h3><ul><li><p>end-to-end 데이터 전송을 위한 WebRTC 프로토콜 : 평균 latency가 500ms까지 낮아질 수 있도록 보장 ( 오디오와 비디오의 동기화를 보장하기 위함 )</p><ul><li>RTCP 제어 프로토콜 / 혼잡 제어 프로토콜 / 패킷 손실 제어 메커니즘 / 에코 제거 / 네트워크 상태 적응 / jitter buffer 등의 기술 이용</ul><li><p>peer간에 적응적으로 제어할 수 있도록 신호처리</p><ul><li>WebRTC 게이트웨이 : RTCP 프로토콜을 통해 peer와 상호작용하여 WebRTC 게이트웨이에서 수신된 오디오 / 비디오 스트림이 동기화되도록 함</ul><li><p>WebRTC 기능을 기반으로 멀티스트림 미디어를 혼합할 때, 혼합 스트림에서 각 오디오 / 비디오를 동시에 동기화 + 각 peer에서 각 스트림을 혼합하는 것이 필요</p><ul><li>즉, $\left|ts(f^x_v(?)) - ts(f_{a \to v}^x(??)) \right|$를 최소화하는 문제<li>고려해야하는 중요 요소<ul><li>여러 채널에서 실시간으로 수신된 최신 오디오 / 비디오 데이터를 혼합하는 것<li>혼합 미디어 데이터가 준비되면 audience의 단말기가 설정한 연결로 <strong>효율적인 실시간 data 전송을 수행</strong>하는 것</ul><li>위 요인에 의해 WebRTC에서 2가지 전략을 채택하여 문제를 해결할 것<ul><li>수신된 오디오 / 비디오 각 채널은 품질을 희생하더라도 동기화할 수 있는 거 높은 우선순위를 가져야함<ul><li>$\left|ts(f^x_v(?)) - ts(f_{a \to v}^x(??)) \right|$가 가장 높은 우선순위로 최소화해야 함 ( realtime 전송을 보장하기 위해 )</ul><li>각 연결의 평균 latency는 멀티스레드 작업환경에서 약 500ms이며, 각 스트림은 다른 스트림을 기다리지 않고 최소의 latency로 대상에게 stream data를 전송해야함<ul><li>mixing frame의 동기화 보장을 전제로, 각 출력 프레임의 동기화 skew value인 $D(f_a^O(k), f_{a \to v}^O(k))$를 최소화해야 함</ul><li>현재로써는 latency와 quality를 모두 잡는 것은 어려움<ul><li>그러나 다른 상황 ( 대화 시나리오 등 ) 에서는 오디오 / 비디오 품질 등이 realtime 전송보다 우선순위가 낮음<li>그래서 우선적으로 낮은 latency를 가지기 위해 위 전략을 받아드려야한다고 주장</ul></ul></ul><li><p>동기화 / forwarding 알고리즘</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>Procedure 3
    Input : Real Time at width the start_v video start to be sent,
    and the currently accumulated video time sum_v
</pre></table></code></div></div><pre><code class="language-pseudocode">1| Video synchronize function()
2|   while (live is not stopping)
3|     if (should send video)
4|       Get the system time cur_ts in nanoseconds, set pts according to the number of frames, and then encode the video frame;
5|       Recalculate pts and dts according to the difference between current time cur_ts and start_v; then pack the corresponding data packets to forward to the ICE Agent according to the WebRTC specification;
6|     Determine whether the audio and video time lag is within the controllable range and sleep if exceeding a specific interval;
</code></pre><pre><code class="language-pseudocode">1| Audio synchronize function()
2|   while (live is not stopping)
3|     if (should send audio)
4|       Determine the system time cur_ts in nanoseconds, increment 960 to pts, then encode the audio;
5|       Recalculate pts and dts according to the difference between current tume cur_ts and start_v; then pack the corresponding data packets to forward to the ICE Agent according to the WebRTC specification;
6|     Determine whether the audio and video time lad is within the controllable rage and sleep if exceeding a specific interval;
</code></pre><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Output : WebRTC data packets
</pre></table></code></div></div><ul><li>각각의 function을 2개의 thread로 이해할 수 있음<li>알고리즘은 외부 instruction에 의해 재귀조건을 만족함</ul><li><p>오디오 / 비디오는 일정한 간격으로 생성됨</p><ul><li>line 3, 11 : 이전에 보낸 혼합 스트림의 시간으로부터 간격이 도달했는지를 판단하는 부분 ( 오디오 : 20ms / 비디오 : 40ms )<ul><li>도달했다면 line 4, 12에서 system global time을 가져옴<li><code class="language-plaintext highlighter-rouge">pts</code>를 frame count에 따라 증가시킴 // 이후 비디오 프레임을 encode<ul><li>하나의 오디오 프레임은 960 샘플을 포함하므로, 오디오에서는 <code class="language-plaintext highlighter-rouge">pts</code>를 960개 증가시켜야함</ul></ul></ul><li>line 5, 12 : <code class="language-plaintext highlighter-rouge">pts</code>와 <code class="language-plaintext highlighter-rouge">dts</code>를 재생성<ul><li><code class="language-plaintext highlighter-rouge">cur_ts</code> - <code class="language-plaintext highlighter-rouge">start_v</code>라는 그들의 <code class="language-plaintext highlighter-rouge">timebase</code> 값에 따라 재생성<li>이후 WebRTC 사양에 따라 해당 data packet을 ICE agent로 전달하기 위해 pack</ul><li>오디오 / 비디오 프레임 간격이 다르므로 WebRTC peer는 전송할 때 다른 video fps를 설정할 수 있음<ul><li>다중 thread mutex waiting 환경에서는 quasi-peer가 보낸 mixed stream에서 각 프레임에 대한 정확한 동일간격을 달성하기 어려움<li>line 6, 13 : 실제 비디오 / 오디오 스트림 중 하나는 reference로 잡음<ul><li>비디오가 6프레임 들어왔다면, 이상적인 상황에서는 오디오가 12프레임 들어와야함<li>만약 적게 들어왔다면 다음 프레임과의 간격을 적절히 감소시킴 ( 반대라면 더 키움 )</ul></ul><li>오디오 / 비디오가 모두 전송될 준비가 되기 전, 각각의 전송 data buffer의 최신 data가 먼저 인코딩된 후 전달됨<ul><li>line 6, 13 : 오디오 / 비디오 상호적응의 동기화 매커니즘 도입<ul><li>이론적으로, 오디오 / 비디오는 주파수가 고정되있다면 동기화될 수 없음<ul><li>오디오 주파수가 비디오에 비해 매우 높음 + 컴퓨터 부동소수점 번호가 thread 자원의 상호배제 중에서 처리됨 -&gt; <strong>오디오 / 비디오 사이에는 상당한 시차가 있음</strong></ul><li>global timeline에서 <code class="language-plaintext highlighter-rouge">dts</code>, <code class="language-plaintext highlighter-rouge">pts</code>를 올바르게 재설정하여 <u>오디오 / 비디오의 동기화를 조정하는 매커니즘 도입</u><ul><li><code class="language-plaintext highlighter-rouge">dts</code> : Decoding TimeStamp ( 디코더가 디코딩될 시기 )<li><code class="language-plaintext highlighter-rouge">pts</code> : Presentation TimeStamp ( playback 중에 프레임이 표시될 시기 )</ul></ul></ul><li>요약<ul><li>ICE agent에 준비하기 위해 Procedure 3의 media data 최종 확정<li>WebRTC network / 일반 CDN 등에서 청중에게 궁극적으로 배포를 위한 제공</ul></ul><h2 id="experiments">Experiments</h2><ul><li>quasi-peer와 시스템 전체를 다른 네트워크 조건 / 해상도 / bit rate 등의 조건을 달리하며 테스트 진행<li>합리적인 mainstream running 환경에서 수용 가능한 latency / 동기화 quality를 가져야하므로, 총 3가지의 테스트 실행<ul><li>latency 테스트<li>동기화 테스트<li>성능 테스트</ul><li>테스트 구성<ul><li>WebRTC 게이트웨이 : iMac, Intel Core i5 3.2 GHz, 16 GB memory<li>STUN/TURN : Intel(R) Core(TM) i7-6700 CPU @ 3.40 GHz, 8GB memory<li>웹캠 등의 다른 device들은 실제 영향을 크게 미치지 않으므로 설명 제외</ul></ul><h3 id="a-latency">A. Latency</h3><ul><li>quasi-peer와 시스템 전체인 경우 2가지의 구성 테스트<ul><li>실험결과를 FFmpeg를 기반으로 한 유사 모델과 비교<li>실험결과를 WebRTC, CDN의 표준 latency와 비교</ul><li><p><strong>The Quasi-peer Module</strong></p><ul><li><p>WebRTC 게이트웨이의 quasi-peer의 latency data와 제어 그룹에 적합한 quasi-peer의 대응 요소를 결정할 수 없음 -&gt; 동일한 사양으로 진행되는 FFmpeg 기반 소프트웨어의 latency data를 그룹으로 사용</p><li><p>FFmpeg 자체가 mixed stream 방법을 제공하지 않음</p><ul><li>다른 교수가 만들어낸 FFmpeg를 기반으로 실험</ul><li><p>실험집단 : 4개의 peer에 대해 모든 과정 수행 // 통제집단 : 거의 동일한 스트림 파일을 입력으로 사용</p><ul><li><p>4개의 오디오 / 비디오 채널 집합 생성</p><li><p>3단계의 해상도 사용 ( 480p, 720p, 1080p )</p><li><p>5개의 bit rates ( 128k, 512k, 1M, 2M, 3M bps )</p><li><p>최소 1만 프레임의 경과 시간을 테스트 후 산술평균 도출</p><li><p>결과</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"> <th style="text-align: center">-&gt;<th style="text-align: center">480p<th style="text-align: center">-&gt;<th style="text-align: center">720p<th style="text-align: center">-&gt;<th style="text-align: center">1080p<tbody><tr><td style="text-align: center"> <td style="text-align: center">quasi<td style="text-align: center">FFmpeg<td style="text-align: center">quasi<td style="text-align: center">FFmpeg<td style="text-align: center">quasi<td style="text-align: center">FFmpeg<tr><td style="text-align: center">128k<td style="text-align: center">1.295<td style="text-align: center">7.822<td style="text-align: center">3.338<td style="text-align: center">20.644<td style="text-align: center">5.516<td style="text-align: center">44.627<tr><td style="text-align: center">512k<td style="text-align: center">1.412<td style="text-align: center">9.245<td style="text-align: center">3.345<td style="text-align: center">22.848<td style="text-align: center">5.647<td style="text-align: center">46.951<tr><td style="text-align: center">1M<td style="text-align: center">1.485<td style="text-align: center">10.373<td style="text-align: center">3.452<td style="text-align: center">24.794<td style="text-align: center">5.923<td style="text-align: center">49.684<tr><td style="text-align: center">2M<td style="text-align: center">1.516<td style="text-align: center">12.546<td style="text-align: center">3.486<td style="text-align: center">29.071<td style="text-align: center">6.104<td style="text-align: center">54.461<tr><td style="text-align: center">3M<td style="text-align: center">1.532<td style="text-align: center">14.394<td style="text-align: center">3.523<td style="text-align: center">29.623<td style="text-align: center">6.153<td style="text-align: center">59.183</table></div><ul><li>제안한 방법이 훨씬 낮은 latency를 가지고 있는 것으로 확인<li>비디오 해상도의 증가 -&gt; latency의 증가라는 상관관계 확보<li>Q. bit rate가 바뀌면 디코딩 / 인코딩 과정 latency에 영향을 미칠까?<ul><li>A. 자신들의 방법은 차이가 거의 없으며, FFmpeg는 비디오 해상도가 높아질수록 더 빠르게 증가<li>FFmpeg : 범용 멀티미디어 process를 위한 프레임워크 -&gt; filter processing이 pipeline 방식으로 수행되므로 간단한 프레임 스케일링 작업도 여러 프로세스에 의해 완료되어야함<li>또한 각 step은 완벽한 frame processing flow를 가져야함</ul><li>자신들의 방법 또한 해상도에서 어느 정도의 latency 증가를 겪음</ul></ul></ul><li><p>요약</p><ul><li>quasi-peer의 latency 시험 결과 : WebRTC 프로토콜에서 요구하는 <strong>낮은 latency와 효율적 / 호환적임</strong></ul></ul><h3 id="b-the-system-as-a-whole">B. The System as a Whole</h3><ul><li>전체 latency를 평가하는데 사용되는 중요 요인 : RTT<ul><li>송신기 : local timestamp $T1$를 갖는 ping packet을 수신기로 보냄<li>수신기 : 송신자에게 $T1$을 사용하여 운반하는 pong packet 구축하여 전송<li>송신기 : pong packet의 local timestamp $T2$를 얻음<li>이 두개의 차이 $T2 - T1$을 RTT로 지정</ul><li>WebRTC : 발신자가 오디오 / 비디오 수집 과정에 직접 개입할 수 없음<ul><li>추가 ping data를 전달하기 위해 packet을 직접 수정할 수 없음<li>So, <strong>RTT를 직접 관찰할 수 없음</strong></ul><li>대신 발신자 / 수신자 간의 <u>시차</u>를 얻을 수 있음<ul><li>모바일 : 카메라를 표준 시간 웹 페이지에 조준<li>PC : 동일한 표준 시간 웹 페이지 개방 + 동시에 mixed stream 재생<ul><li>이 때 컴퓨터 화면에 두개를 time로 만든 후 스크린샷을 통해 timestamp를 2개 얻을 수 있음<li>이렇게 얻어진 2개의 timestamp의 차이를 계산 후 산술평균하여 <u>이 시간차를 바탕으로 일정수준 평가할 수 있음</u></ul><li>quasi-peer : 약 500ms의 latency가 있는 WebRTC에서 실행중 // 일부 프로세스 소유<ul><li><strong>시간차는 500ms가 약간 넘지만, 그 이상은 아니어야한다</strong></ul><li>일반적으로 CDN latency는 약 5s -&gt; quasi-peer에 의한 혼합 스트림이 궁극적으로 일반 CDN에 전달될 때 latency 요구사항을 보장하기 위해 5s보다 작아야함</ul><li>실제 시나리오 시뮬레이션하기 위해 아래와 같은 상황에서 비교 테스트<ul><li>다른 네트워크<ul><li>유선 ( 1000M ) / 무선 WIFI ( 300M )</ul><li>다른 해상도<ul><li>480p / 720p / 1080p</ul><li>live screenshot를 통해 발신기 / 수신기에서 timestamp를 얻을 수 있고, 그것의 차이로 시차를 얻을 수 있음</ul><li>위의 방법을 이용하여 실제 latency는 아니지만, latency라고 부를 수 있는 시차를 계산할 수 있음<ul><li>서로 다른 네트워크 / 해상도에서 15번 시도하여 관찰<li>결과 : 일반적인 latency = 약 600ms<ul><li>케이블 네트워크가 가장 빠르고 변동이 적었음</ul></ul><li>요약<ul><li>제안한 방법은 서로 다른 네트워크에 적응 + 상대적으로 낮은 latency 달성 가능<li>많은 시청자에게 여러 peer의 시나리오에 적응할 수 있음을 보임</ul></ul><h3 id="c-synchronization">C. Synchronization</h3><ul><li><p>공식 (3)을 ITU-R BT.1359 표준과 결합하면 새로운 공식으로 단순화할 수 있음</p><ul><li><p>오디오 / 비디오 동기화를 정량적으로 평가하는데 사용 가능</p><p>$T = (pt_v - gt_v) - (pt_a - gt_a) \tag{7}$</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">기호<th style="text-align: center">설명<tbody><tr><td style="text-align: center">$T$<td style="text-align: center">특정 표준시간에 대한 시간 차이<tr><td style="text-align: center">$gt_a$<td style="text-align: center">오디오가 생성된 특정 표준시간<tr><td style="text-align: center">$gt_v$<td style="text-align: center">비디오가 생성된 특정 표준시간 ( 위와 이상적으로는 같아야 함 )<tr><td style="text-align: center">$pt_v$<td style="text-align: center">사용자가 live로 그림을 보는 실제 시간<tr><td style="text-align: center">$pt_a$<td style="text-align: center">사용자가 live로 오디오를 듣는 실제 시간</table></div><ul><li>$T$가 클수록 방송의 동기화가 불가능해짐</ul><li><p>ITU-R BT.1359 표준에 따르면, $T$의 값에 따라 sync가 다름을 알아차림</p><ul><li>$T = [-100ms, 25ms]$인 경우 차이를 느끼지 못함<li>$T &lt; -125$ms or $T &gt; 45$ms인 경우 차이를 느끼지만 적응할 수 있음<li>$T &lt; -185$ms or $T &gt; 90$ms인 경우 동기화 문제를 분명하게 알아챔</ul></ul><li><p>인간 오류나 편향을 없애기 위해 간단하고 객관적인 방법을 사용하려 함</p><ul><li>Snagit를 이용하여 혼합 오디오 / 비디오에 tapping event를 넣음<li>소리 / 화면 등을 이용하여 오디오 / 비디오의 차이 $T$를 계산<li>만약 $T$가 $[-100ms, 25ms]$보다 작다면 동시에 일어나는 것처럼 보이며, <strong>동기화되었다고 판단할 수 있음</strong><li>총 20번의 랜덤 tapping event를 넣어본 결과 $T = [-10ms, 10ms]$라는 결과를 얻음<ul><li>오디오 / 비디오가 성공적으로 동기화되었음을 보임</ul></ul></ul><h3 id="d-performance">D. Performance</h3><ul><li>수신기의 품질 테스트 필요<ul><li>audience들이 비디오 품질에 만족하는가?</ul><li>quasi-peer의 CPU, 메모리 소비량 등 테스트 필요<ul><li>실행 비용이 합리적인가?</ul><li>테스트 방법 : Gateway에 내장된 quasi-peer 내에 network conversation 설정<ul><li>이후 수신기 -&gt; Chrome 브라우저까지 WebRTC traffic 상태 / 자원소비 등을 모니터링</ul></ul><h5 id="1-the-receiver">1. The Receiver</h5><ul><li>현재 stream의 안정성을 보여주는 그림이 있음 ( Chrome이 혼합 매체를 재생하는 상태 )<li>video frame rate 안정성 : 곡선의 변동에 의해 직접 결정됨<ul><li>비디오 형식으로 정의된 프레임 속도 근처에서 안정적이라면, 비디오 또한 안정적이라고 인식 가능<li>만약 곡선이 안정적이지 못하다면 비디오 또한 불안정해 보일 것</ul><li>결과 : 톱니 모양의 직선과 유사한 모양을 나타냄 ( <strong>혼합 비디오가 수신기에 매우 유창하게 들어가고 있음</strong> -&gt; 혼합 비디오가 안정적으로 출력되고 있음 )</ul><h5 id="2-the-quasi-peer">2. The Quasi-peer</h5><ul><li><p>1080p traffic의 채널 4개를 포함하는 quasi-peer를 시뮬레이션</p><ul><li>이후 15개의 다른 시점에서 무작위로 CPU / 메모리 사용량을 체크</ul><li><p>결과 : 사용량이 합리적이라고 보임</p><ul><li><p>메모리 사용량</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">구분<th style="text-align: center">사용량<tbody><tr><td style="text-align: center">최대<td style="text-align: center">118MB<tr><td style="text-align: center">중앙값<td style="text-align: center">108MB<tr><td style="text-align: center">75% ~ 25%<td style="text-align: center">107 ~ 110.6MB</table></div><li><p>CPU 사용량</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">구분<th style="text-align: center">사용량<tbody><tr><td style="text-align: center">최대<td style="text-align: center">42%<tr><td style="text-align: center">중앙값<td style="text-align: center">41.2%<tr><td style="text-align: center">75% ~ 25%<td style="text-align: center">40.9 ~ 41.5%</table></div><li><p>여러 peer -&gt; 다수의 audience로 제공하는 시나리오에서, <strong>quasi-peer를 이용한 시스템이 순조롭게 운영되고 있음</strong>을 보임</p><li><p>하드웨어 자원 소비도 합리적일 것 ( WebRTC 게이트웨이 test 머신과 동일한 사양을 가진 서버의 비용 또한 중저가가 될 것이기 때문 )</p></ul></ul><h2 id="conclusion">Conclusion</h2><ul><li>멀티채널 WebRTC live 스트림을 효율적으로 혼합하는 방법 제안<li>여러 peer들이 생성한 WebRTC 프로토콜 스트리밍 media data를 실시간으로 조합<ul><li>성능을 유지하며 오디오 / 비디오 동기화를 보장, 합리적인 실행비용 보장</ul><li>latency, 동기화, 성능에 대한 실험으로 어느 정도 수준에서 문제를 해결할 수 있음을 보임<li>quasi-peer가 오디오 / 비디오를 동기화할 수 있음 -&gt; WebRTC 이외의 일단 CDN과 같은 일반 릴레이 서버에서도 다른 media 형식의 output를 쉽게 생성 가능<li>개발자가 gateway 서버의 몇가지 간단한 설정을 제외하면 실제 WebRTC에서 하는 작업보다 많은 일을 할 이유는 없음<ul><li>quasi-peer가 audience들에게 peer들로 적용할 수 있는 길을 열어준다고 생각함</ul><li><strong>아직 더 많은 개선이 필요함</strong><ul><li>인코딩 / 디코딩 효율 향상을 위해 CUDA와 같은 병령 컴퓨팅 framework를 도입할 수 있음<li>네트워크 한계 / 컴퓨팅 용량 등을 증가시키기 위해 WebRTC gateway에 SDN을 도입 가능<ul><li>여러 WebRTC gateway와 협력하여 스트림 forwarding / mixing 개선<li>전체 시스템을 확장할 수 있도록 함</ul><li>peer와 audience 포함하여 모든 참여자에게 전체 시스템간의 스트림 distribute를 빠르게 하기 위해, 머신러닝 기법을 도입할 수 있음<ul><li>각각의 네트워크 조건 / habit에 대한 역사적 정보를 바탕으로, 스트림을 전달하기 위한 가장 가까운 경로를 찾아야 함</ul><li>동기화 / latency 문제를 계속해서 해결해나갈 것<ul><li>현재의 기술적 장애 및 많은 비용 문제를 해결해갈 것</ul></ul></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/imes/'>IMES</a>, <a href='/categories/paper/'>paper</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/imes/" class="post-tag no-text-decoration" >IMES</a> <a href="/tags/paper/" class="post-tag no-text-decoration" >paper</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Audio and Video Mixing Method to Enhance WebRTC - Joe2357&url=https://joe2357.github.io/posts/WebRTC/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Audio and Video Mixing Method to Enhance WebRTC - Joe2357&u=https://joe2357.github.io/posts/WebRTC/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Audio and Video Mixing Method to Enhance WebRTC - Joe2357&url=https://joe2357.github.io/posts/WebRTC/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/SCPC-2021-Round-1/">SCPC 2021 1라운드 후기</a><li><a href="/posts/SCPC-2020-Round-1/">SCPC 2020 1라운드 후기</a><li><a href="/posts/728/">Codeforces Round #728 (Div. 2) 후기</a><li><a href="/posts/727/">Codeforces Round #727 (Div. 2) 후기</a><li><a href="/posts/726/">Codeforces Round #726 (Div. 2) 후기</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ps/">PS</a> <a class="post-tag" href="/tags/review/">Review</a> <a class="post-tag" href="/tags/codeforces/">Codeforces</a> <a class="post-tag" href="/tags/imes/">IMES</a> <a class="post-tag" href="/tags/paper/">paper</a> <a class="post-tag" href="/tags/scpc/">SCPC</a> <a class="post-tag" href="/tags/ds/">DS</a> <a class="post-tag" href="/tags/storage/">Storage</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/PBE-CC/"><div class="card-body"> <span class="timeago small" > Nov 26, 2020 <i class="unloaded">2020-11-26T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>PBE-CC: Congestion Control via Endpoint-Centric, Physical-Layer Bandwidth Measurement</h3><div class="text-muted small"><p> 2021 / 1 / 20 IMES 세미나 Abstract cellular network는 복잡해지고 과밀되어짐 delay, jitter 등의 문제 발생 PBE-CC : sender가 정확하고 급격하게 반응할 수 있도록 하는 최신 5G radio 혁신 기반 congestion control 알고리즘 ...</p></div></div></a></div><div class="card"> <a href="/posts/MPBond/"><div class="card-body"> <span class="timeago small" > Jan 21 <i class="unloaded">2021-01-21T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MPBond: Efficient Network-level Collaboration Among Personal Mobile Devices</h3><div class="text-muted small"><p> 2021 / 2 / 17 IMES 세미나 Abstract MPBond : 여러 개인 mobile device가 공동으로 internet에서 content를 가져올 수 있도록 하는 효율적인 system 스마트워치 : data downloading을 통해 페어링된 스마트폰 지원 MPTCP ( Multipath...</p></div></div></a></div><div class="card"> <a href="/posts/Edge-Assisted-Real-time-Object-Detection-for-MAR/"><div class="card-body"> <span class="timeago small" > Feb 17 <i class="unloaded">2021-02-17T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Edge Assisted Real-time Object Detection for Mobile Augmented Reality</h3><div class="text-muted small"><p> 2021 / 3 / 18 IMES 세미나 Abstract 대부분의 AR/MR : 주변 환경의 3D 형상을 이해할 수 있음 단점 : 현실의 복잡한 물체 탐지, 분류하는 능력 부족 해결 방법 : CNN에서 기능을 활성화할 수 있음 단점 : mobile device에서 대규모 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/710/" class="btn btn-outline-primary" prompt="Older"><p>Codeforces Round #710 (Div. 3) 후기</p></a> <a href="/posts/726/" class="btn btn-outline-primary" prompt="Newer"><p>Codeforces Round #726 (Div. 2) 후기</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/username">Joe2357</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/ps/">PS</a> <a class="post-tag" href="/tags/review/">Review</a> <a class="post-tag" href="/tags/codeforces/">Codeforces</a> <a class="post-tag" href="/tags/imes/">IMES</a> <a class="post-tag" href="/tags/paper/">paper</a> <a class="post-tag" href="/tags/scpc/">SCPC</a> <a class="post-tag" href="/tags/ds/">DS</a> <a class="post-tag" href="/tags/storage/">Storage</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://joe2357.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
